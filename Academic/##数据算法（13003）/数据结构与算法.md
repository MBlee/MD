## 绪论

#### 基本概念和术语

```shell
# 数据
是指所有能输入计算机并被计算机程序处理的符号的集合
-数据是各种各样的
-复杂的数据往往由简单的数据构成
-构成数据的基本单位称为数据元素
-数据元素还可以细分为数据项
# 数据结构
数据元素之间的相互关系构成结构，
带有结构特性的数据元素集合构成数据结构
-逻辑结构:指数据元素之间的逻辑关系
-物理结构:指数据结构在计算机中的表示及存储方式
数据的逻辑结构从逻辑上描述数据，
表明数据元素之间的关系是什么样的，这与数据的存储方式无关，
既独立于计算机，也独立于程序设计语言
-数据的最小不可分割的单位是数据项
-逻辑上相关的、具有物理意义的若干数据项构成一个数据元素
-数据元素作为一个完整的对象(整体)是构成数据的基本单位
```

```shell
# 基本数据结构
# 集合:
结构中的数据元素除了“同属于一个集合”外，
没有其它关系
# 线性结构:
结构中的数据元素之间存在一对一的关系
# 树结构:
结构中的数据元素之间存在一对多的关系
# 图结构:
结构中的数据元素之间存在多对多的关系。
```

```shell
# 常用存储方法
# 顺序存储方法:
用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)，
存放地址是连续的。
# 链式存储方法:
用指针来表示数据元素之间的逻辑结构(关系)。
存放地址是否连续没有要求。
# 索引存储方法:
存储结点信息的同时，建立附加的索引表。
索引表由索引项组成
# 散列存储方法:
根据结点的关键字通过散列函数直接计算该结点的存储地址。
```

```shell
# 数据类型
指的是一个值的集合和定义在该值集上的一组操作的总称。
数据类型中定义了两个集合，
-该类型的取值范围，
-该类型中可允许使用的一组运算。
在C语言中数据类型有:
-基本类型:整型，实型，字符型等
-构造类型:数组，结构体等
在高级语言中，
整型类型可能的取值范围是-32768~+32767，
可用的运算符集合为加、减、乘、除、取模(如C语言中+,*,%)。
# 抽象数据类型
-抽象数据类型的定义
包括类型的名字及对各个操作的刻画，
也就是要明确“做什么”
-对于每个操作，要规定操作的名字、
操作执行的前提条件、
输入和输出分别是什么等等。
每个操作通常表示为一个函数或是方法
# 定义格式
ADT<抽象数据类型名>
{数据对象:<数据对象的定义>
结构关系:<结构关系的定义>
基本操作:<基本操作的定义>
}ADT<抽象数据类型名>
ADT Triangle{//三角形的抽象数据类型
定义数据部分:
	a,b,c;//表示构成三角形的三条边，实型
操作部分:
	area(a,b.c)//给定三条边，计算三角形面积
		输入:a,b.c
		输出:三角形的面积
		前提条件:三条边满足构成三角形的条件
	perimeter (a.b,c)//给定三条边，计算三角形周长
		输入:a,b,c
		输出:三角形的周长
		前提条件:三条边满足构成三角形的条件
}ADT Triangle
```

#### 算法和算法分析

```shell
# 算法
是一个由若干确定的(无二义性的)、
可执行的步骤组成的
肯定能够终止的有序步骤集合
算法是描述一个问题的求解过程，
它由一系列解决问题的清晰指令构成
-可以使用自然语言表示
-可以使用计算机程序设计语言表示
-可以混合使用自然语言与计算机程序设计语言
# 例题
将摄氏温标值C转换为华氏温标值F
已知计算公式为:F=(9/5)C+32
转换的过程使用自然语言表示:
输入一个摄氏温标值C
C乘以常数9/5(或1.8)
前一步的乘积与常数32相加，
得到F输出结果F，
即转换后的华氏温标值

转换的过程使用计算机程序设计语言表示:
#include <stdio. h>
int main(int argc,char **argv)
double Ctemp，Ftemp;//分别代表两种温标值
const double fac=1.8, inc=32.0;
printf("输入摄氏温标值:");
Scanf ("%If",&Ctemp);
Ftemp=Ctemp*fac+inc;
printf("摄氏%3.11f 度对应的华氏温标值是:%3.11f\n",Ctemp,Ftemp);
return 0;
# 算法特性
输入:有0或多个输入值
输出:有1或多个输出值
有穷性:一个算法必须在执行有穷步骤之后结束
确定性:算法的每一个步骤必须是有确切含义的
可行性:算法中要做的运算都是相当基本的、能够精确进行的

算法必须要正确，
所以算法的正确性成为评判算法的首要指标
评判算法的其他方面:执行效率
·时间复杂度
·空间复杂度
```

```shell
# 时间复杂度
计算机中最重要的资源之一是CPU，
显然，花费的时间与处理的数据个数有很大的关系，
这个数据个数称为问题规模，也称问题大小。
执行算法花费的时间表示为
问题规模的一个函数
统计一个程序执行期间需要执行的语句总数，
并且约定，
程序设计语言中一条基本语句的执行时间为1个单位时长

一个算法的时间效率可以用问题规模
及关键的处理步骤的多少来定义
将算法的运行效率表示为问题规模n的一个解析式，
对于规模为n的问题，解析式计笑的值，
应该是算法处理的步骤数
将关于n的这个解析式称为增长函数，表示为T(n)
对于一个具体的算法，
其增长函数是一个近似的表达式

# 渐近时间复杂度
考查增长函数时，只关心增长函数表达式中的主项，
并且不再考虑主项的系数
表达式的主项使用记号0来表示
例1.5中增长函数表示为0(n)
例1.6中增长函数表示为O(n2)
这称为渐近时间复杂度，也称为算法的阶

大O表示法和大Q表示法
使我们能够描述某一算法的上限
(如果能找到某一类输入下开销最大的函数)
和下限(如果能找到某一类输入下开销最小的函数)
当上、下限相等时，可用表示法。
如果一种算法既是0(f(n))，
又是Q(f(n))，则称其是(f(n))的
```

```shell
# 常见时间复杂度
-若增长函数不随算法问题规模变化，
则增长函数称为O(1)阶，或称常数复杂度
-与问题规模成正比的问题求解算法称为线性操作
-许多算法具有log2n对数复杂度
-其他的算法有n的某次幂的多项式复杂度，如0(n2)或0(n3)
-更坏的算法是指数复杂度，n是指数，如O(2n) 
```

```shell
# 空间复杂度
除了要评判算法的时间复杂度外，
算法在运行过程中临时占用的空间大小也要考虑，
这称为空间复杂度。
一般地，空间复杂度也表示为问题规模的一个函数。
考虑空间存储量时，算法代码占用的空间、
算法中初始数据占用的存储空间，都不包含在内。
```

#### 算法设计策略简介

```shell
# 设计策略
设计策略有时也可以称为设计方法，
是指在解决特定问题时所采用的一类方法,包括:
递推法、迭代法、递归法、贪心法、分治法、动态规划法等
```

```shell
# 一、递推法
递推法是一种直接求解的算法设计策略，
利用问题本身所具有的一种递推关系进行求解。
找到问题本身的递推关系是问题求解的前提。

递推法的思想是，
根据递推关系，
能从已求得的问题规模为1.2,....i-1的一系列解，
构造出问题规模为i的解。

求解规模为i的解时，
有时可能仅需规模为1.2,...，i-1的系列解中的一部分，
而不是全部
```

```shell
# 二、迭代法
是一种直接求解的方法，
往往需要建立迭代关系式

-即根据前一个值推出下一个值的公式
初始时设定初始值(原值)，
然后根据迭代关系式和原值，求出新值，
并用新值替代原值

迭代过程不能无限进行下去
-或者设定一个迭代次数，
当达到这个次数时迭代过程停止
-或者设定一个结束条件，
当满足这个条件时，迭代过程停止
```

```shell
# 三、递归法
直接或间接地调用自身的算法定义为递归算法;
直接或间接地调用函数本身的函数称为递归函数。
```

```shell
# 四、贪心法
贪心算法也称贪婪算法，
这是一种通过每一步选择局部最优解
来达到整体最优解的算法，
适用于求某些最优解问题

求解过程中，一步一步地进行，
根据当前的情况选择最优的可能

实际上，这个最优是在当前条件下的最优，
称为局部最优
-第四章构造哈夫曼树
-第六章求最小生成树
```

```shell
# 五、分治法
当求解一个输入规模为n并且n的取值又很大的问题时，
可以把这个大规模的问题分解为
若干个规模更小且可以独立求解的问题，
然后把各个小问题的解进行合并，
得到原问题的解。
这就是分治法的思想

一般来说，
分治法的求解过程分为三个阶段
-即划分、求解小问题及小问题解的合并
-第七章的快速排序和归并排序，
将大问题分解为2个小问题进行求解
```

```shell
# 六、动态规划法
动态规划算法是求多阶段决策过程最优化的一种方法，
它将问题的整体按时间或空间的特征分成
若干个前后衔接的阶段，
把多阶段决策问题表示为
前后有关的一系列单阶段决策问题，
然后逐个求解，从而求出
整个问题的最优决策动态规划法
强调了时间和空间的连续性
```

## 线性表

#### 线性表的定义和基本操作

```shell
线性表是一种线性结构。
在这种结构中，
存在着唯一的“第一个”元素、唯一的“第二个”元素，
依此类推。
线性表中各个元素依次排列。
例如，在例1-1中，表1-1列出的某班30名学生的基本信息
能够组成一个线性表，
可以按照学号排列名单。
```

```shell
# 定义
一个线性表(linearlist)是
由同类型数据元素构成的有限序列
由n(n≥0)个元素组成的线性表L，
可以表示为L=(ao,a1,...,an-1)
这里，a(0≤i≤n-1)
即是线性表中的数据元素，也称为表项
# 特点
-线性表中所有数据元素都必须是相同类型的
-数据元素的次序就是它们在表中的排列次序
-第一个元素是a0，称为表头或开始元素
-第n个也即最后一个元素是an-1，称为表尾或终端元素
-元素的个数n称为表长
-n=0时称为空表，记为()

-线性表中常使用非负整数表示各元素的位置
-表头a的位置为0
-a的位置为1
-a;(0≤i≤n-1)的位置为i
-对于元素a;(1≤i≤n-1)，元素a;
(0≤jくi)称为a的前驱，
其中元素a称为a的直接前驱(可简称为前驱)
-对于元素a;(0≤i≤n-2)，
元素aj(i<j≤n-1)称为a;的后继，
其中元素a称为a;的直接后继(可简称为后继)
```

```shell
# 例1
将例1-1的学生基本信息表表示为线性表Student
Student=
((M2022103001 王义平男2004.11.22 山东)，
(M2022103002陆东男2004.02.05河南)，...，
(M2022103030 杨志强男2004.10.30 陕西))
```

#### 线性表的顺序存储及实现

```shell
-操作的具体实现需要依赖于线性表的存储结构
-顺序存储结构使用数组保存线性表中的各元素，
相应的线性表称为顺序表
-链式存储结构使用链表保存线性表中的各元素，
相应的线性表称为链表
```

```shell
# 顺序表
- 顺序存储的基本思想是
使用一组连续的存储单元依次存储各个元素，
将线性表中的各数据元素，按照其逻辑次序，
依次保存在数组的各个单元中
- 线性表中逻辑上相邻的两个元素，
保存在数组相邻的两个单元中，
分配一个多大的数组是个挑战
- 数组是内存中一片连续的空间，
相邻的两个单元在内存中的实际地址也是相邻的，
这表明，线性表中逻辑上相邻的两个元素，
其存储地址也是相邻的

- 数组下标与线性表元素的位置相对应
- 线性表元素依次存放的特性，
决定着表中元素i(i≥0)存储在数组的下标i处
- 表头元素保存在位置0处，
这个位置也称为数组的首地址
- 只要给定数组下标，
就能立即计算出相应元素的存储地址，
并据此访问该元素
# 地址计算
设L0C(a)表示元素a的存储首地址，
每个元素需占用d个存储单元，则有:
L0C(ai)=L0C(ai-1)+d进一步地有:
L0C(ai)=L0C(a0)+ixd
LOC(a0)即是数组的首地址
```

```shell
# 顺序表的插入删除
设给定一个顺序表，
初始时含有5个元素。
在位置2插入元素27，
然后删除位置3的元素
```

```c
// 顺序表的定义
typedef int ELEMType;
typedef struct{
    ELEMType element[maxSize];//保存元素的数组，最大容量为maxSize
    int n;//顺序表中的元素个数
}SeqList
typedef SeqList LinearList;
typedef int Position;
// 查找
Position find(SeqList *L,ELEMType x)//返回元素x在表L中第一次出现的位置
int i;
for(i=0;i<L->n;i++)
    if(L->element[i]==x)
        return i;
	return ERROR;//表示未找到

// 构造空表及清空表
int initList(SeqList *L)//初始化顺序表，创建一个空表L
	L->n=0;
	return TRUE;
int clear(SeqList *L)//将表L置空
    L->n=0;
	return TRUE;

// 判表空、判表满、求表长
int isEmpty(SeqList*L)//如果表L为空则返回1，否则返回0
	if(L->n--0) return TRUE;
	else return FALSE;
int isFull(SeqList*L)//如果表L已满则返回1，否则返回0
	if(L->n--maxSize) return TRUE;
	else return FALSE;
int length(SeqList*L)//返回表L的当前长度
	return L->n;

// 插入新元素
// 插入操作中移动元素的平均次数为n/2
int insertList(SeqList *L,Position pos,ELEMType x)
    //在表L的位置pos处插入元素x
	inti:
	if(isFull(L)-=TRUE) return FALSE;//表已满
	if(pos<0||pos>L->n) return ERROR;//位置错误，与表满区别开
	for(i=L->n;i>pos;i--)
        L->element[i]=L->element[i-1];//移动元素
	L->element[i]=x;//放置x
	L->n++;
	return TRUE;//表长增1

// 删除操作
// 删除操作中移动元素的平均次数为(~1)/2
int removeList(SeqList *L,Position pos,ELEMType *x)
    //删除表L中位置pos处的元素并通过x返回
	inti:
	if(isEmpty(L)==TRUE) return FALSE;//表空
	if(pos<0||pos>L->n-1) return ERROR;//位置错误，与表空区别开
	*x=L->element[pos];//记下被删除的元素值
	for(i-pos;i<L->n-1;i++)
        L->element[i]=L->element[i+1]://前移元素
	L->n-;//表长减1
	return TRUE;

// 赋值、取值操作
int set Value(SeqList *L,Position pos,ELEMType x)
    //给表L位置pos处的元素赋值x
	if(pos>=0&&pos<L->n)
    	L->element[pos]=x;return TRUE;
	return FALSE;
int getValue(SeqList *L,Position pos,ELEMType *x)
    //返回表L中位置pos处的元素
	if(pos>=0&&pos<L->n)
        *x=L->element[pos];
		return TRUE;
	return FALSE;

// 示例 例2-5
设有顺序表L，表长为n，保存在数组A中。实现算法将L逆置，
即L=(a0, a1, ..., an-2, an-1
变为L=(an-1, an-2, ..., a1, a)
将A[0]与A[n-1]进行交换，
然后将A[1]与A[n-2]进行交换，依此类推，
当交换到中间元素时，算法结束
```

#### 线性表的链式存储及实现

```shell
# 链式存储方式:
线性表中的各个元素
保存在各自的存储空间中，
形成一个个的结点
这些结点在内存中的地址不要求是相邻的，
它们之间通过指针连接起来，
以这种方式保存的线性表称为链表
# 循环链表
-修改单链表的定义，
将表尾结点的指针指回头结点，
从而形成一类新链表
-这样的链表中，从任何一个结点出发
沿着指针域的指示可以再回到这个结点，
好象转了一个圈一样，
形象地称这样的链表为循环链表
```

```shell
# 单向链表
# 双向链表
# 双向循环链表
```

#### 进一步讨论两种基本实现方式

```shell
# 线性表有两种基本的实现方式:分别是顺序实现和链式实现
- 顺序表存储每个数据元素时空间比较紧凑，
并且是占用连续的空间
- 数组的每个单元中只需要保存数据本身，
没有额外的开销
- 链表在每个结点上除存储数据元素外，
还要留出空间存放指针。
单链表中每个结点包含一个指针，
双向链表中每个结点包含两个指针。
这些指针占用的空间称为结构性开销
- 为顺序表分配的数组，通常要宽松一些。
通常数组中会有空闲的空间，
此时并没能充分利用数组的全部空间
- 链表中占用的空间大小与链表中的元素个数成正比，
分配的结点是全部使用的
- 当线性表的元素个数相对较少时，
链表的实现比顺序表的实现更节省空间
- 当线性表中的元素个数接近分配的最大个数，
数组的空间存储效率很高
```

```shell
设n表示线性表中当前元素的个数，
D表示最多可以在数组中存储的元素个数，
也就是数组的大小，
P表示指针的存储单元大小，
E表示数据元素的存储单元大小
顺序表的空间需求为DXE
单链表的空间需求为nX(P+E)
n的临界值n=DXE/(P+E)
双向链表比单链表中每个结点的指针数多1个。
所以双向链表的结构性开销是单链表的2倍
```

```shell
# 例1
设保存线性表L的每个元素需要的空间为10个字节，
指针占2个字节。
若采用单链表或含30个元素的数组保存L。
试分析采用哪种方式空间存储效率更高?
(仅需要考虑L中元素)
根据题意，采用单链表保存L时，
每个结点占用的空间为12个字节。

- 如果采用数组保存，
则需要的空间是30X10=300个字节。
使用这些空间保存单链表中的结点的话，
可以保存300/12=25个结点
- 在不考虑表头结点占用的空间的前提下，
如果L中元素个数少于25个，
则采用单链表更省空间
- 如果多于25个元素，
则采用数组更省空间
- 如果正好是25个元素，
则单链表和数组占用的空间是一样大的
```

```shell
# 如何选择
- 当线性表元素个数变化较大或者未知时，
最好使用链表实现
- 如果用户事先知道线性表的大致长度，
则使用顺序表的空间效率会更高些
- 还要考虑到，顺序表占用的空间是连续的，
而链表占用的空间可能是零散的，
并且还需要程序员来管理空间的分配及释放
- 操作的时间复杂度也要考虑
# 复杂度差异
- 在顺序表中是直接定位的，
可以实现随机访问，
操作的时间复杂度是0(1)
- 单链表不能随机访问指定的元素，
平均时间复杂度和最差时间复杂度均为0(n)
- 在给出指向链表的当前指针后，
在单链表内进行插入和删除操作的时间复杂度也可以达到0(1)
- 顺序表的插入和删除操作，
平均和最差时间复杂度均为0(n)
```

```shell
# 二、空闲单元链表
- 链表中，当需要在链表中插入一个结点时，
需要调用maloc函数分配相应的空间
- 当在链表中删除一个结点时，
需要调用delete函数释放空间。
如果在链表中频繁进行插入、删除结点的操作，
则频繁调用这些函数的时间开销会是非常可观的
- 可以针对实际应用的每类链表，
定义一个“伙伴链表”，
表结点的结构与所使用的链表结构一致
- 伙伴链表用来管理暂时不用的结点，
可以将伙伴链表称为空闲单元链表
- 当从链表L中删除一个结点时，
将这个结点插入到freelist中
- 当需要申请新的结点空间时，
先查看链表freelist。
如果freelist不空，
则从freelist中获取一个结点，
结点中保存相应的值，
并将该结点插入到L的相应位置，
否则调用maloc函数分配新的空间，
并完成后续的插入操作
```

```shell
# 三、静态链表
# 静态链表的特点
- 保存在数组中
- 兼具顺序表和链表特性，空间不零碎，
插入删除不需要移动元素
# 静态链表的操作
在前一个静态链表中插入元素E后的静态链表
```

#### 单链表的应用

```shell
# 一、查找单链表倒数第k个结点
如果知道了单链表的长度，
那么访问倒数第k个结点就很容易了。
假设单链表长度为n，
则倒数第k个结点即是第n-k+1个结点

- 使用两个指针front和rear，
均从表头开始同步向表尾方向移动
- 初始时，先令front前进k步，当个“排头兵”
- 这样front和rear指向的位置相距k个结点
- 然后两个指针同步前进
- 当front到达表尾时，rear即位于倒数第k个结点
```

```shell
# 二、查找单链表的中间结点
使用两个指针，
并同时从表头开始向表尾方向移动，
一个指针一次走两步，
另一个指针一次走一步。
这样，当“排头兵”指针到达表尾时，
后面的指针即指向链表的中间结点。
与findKth函数中一样，
两个指针分别是front和rear
```

```shell
# 三、将单链表逆置
- 使用3个指针分别指向相邻的三个结点，
接下来让middle所指结点的next域指向left所指结点，
即left所指结点的原后继(middle所指)变为它的新前驱。
然后，三个指针依次后移一个位置
- 当所有结点中的next域都转向后，
再将head所指的头结点链接在表头处
```

## 栈和队列

#### 栈

```shell
# 一、栈的定义及其基本操作
栈(stack)是限定仅在一端进行插入和删除的线性表
能进行插入和删除的这一端称为栈顶，
线性表的另一端称为栈底在栈顶
插入一个元素称为入栈(push)、进栈或压栈，
从栈顶删除一个元素称为出栈(pop)或退栈
# 栈的表示
将栈S表示为:S=(a,a,..,an-1)
通常指定an1一端为栈顶，
a0一端是栈底
栈中元素个数n称为栈的长度，
当n=0时，称为空栈
# 栈的特点
栈具有后进先出(LIFO，Last In FirstOut)的特性
- 只要栈不空，就允许出栈
- 只要栈不满，就允许入栈
- 当没有其他的特殊限制时，
对于同一个入栈序列，
可能会得到很多个合理正确的出栈序列
```

```shell
# 二、栈的存储及其实现
栈有两种主要的存储方式
- 顺序存储
- 链式存储
- 顺序存储方式使用数组保存栈元素，
得到的是顺序栈
- 链式存储方式使用单链表保存栈元素，
得到的是链式栈
# 1、顺序栈及其实现
- 在顺序栈中，
栈中的元素保存在一维数组中，
将栈底定义在数组下标为0的位置
- 同时使用一个变量标记栈顶的位置，
即栈顶位置
- 栈顶位置也称为栈顶指针
# 效率
- top的值既是保存下一个入栈元素的位置，
也是栈中所含元素个数的计数器
- 因为栈的入栈操作及出栈操作都在栈顶进行，
所以入栈、出栈、获取栈顶元素
时都不需要移动栈中已有的元素，
故时间复杂度都是0(1)
- 判定栈空及栈满等操作的时间复杂度也是0(1)

# 对顶栈
- 数组的两个端点分别作为两个栈的栈底
- 左侧栈占用数组0到k的单元，栈顶在k+1位置
- 右侧栈占用数组m-1到h的单元，栈顶在h-1位置
- 此时必须满足kh，才能保证两个栈不会重叠
- 栈S1入栈时，栈顶值增大，出栈时栈顶值减小
- 栈S2刚好相反，入栈时栈顶值减小，出栈时栈顶值增大

# 2、链式栈
所谓的链式栈，
- 可以看作是一个仅在表头位置进行操作的单链表
- 将头指针所指的这一端作为栈顶，表尾一端作为栈底
- 入栈操作及出栈操作都可以通过头指针完成。
所以，在链式栈中，可以只定义头指针，
尾指针及头结点都可以不定义
# 初始化
栈初始时是个空栈，所以指向栈顶的指针赋值NULL
# 出栈
- 仅当栈不为空时才能执行出栈操作，
所以pop函数中要先判断栈不为空
- 出栈后，将栈顶元素的值通过x返回给调用者
- 元素所占用的空间要释放掉
# 入栈
入栈时，需要创建一个新结点，
并将新结点插入在栈顶位置

# 3、顺序栈与链式栈的比较
- 实现顺序栈和链式栈的所有操作都只需要常数时间，
因此栈的两种实现方式的优劣
仅体现在它们的存储效率上
- 顺序栈需要预先申请一个固定长度的一维数组，
并自始至终全部占用，当栈中元素个数相对较少时，
空间浪费较大
- 链式栈的长度虽然可变，但是每个元素都需要一个指针域，
这又产生了结构性空间开销
- 栈是保存调用信息的最佳结构
- 系统内部会开辟一个函数调用栈用来保存函数
在调用过程中所需要的一些信息
```

#### 队列

```shell
队列也是一种特殊的线性表，
其特殊性也体现在
操作的位置上它具有优先的特性，
即先来的先得到服务这种先来先服务的特性
称为先进先出(First In First Out)，简称FIFO
# 定义
定义3-2队列(queue)是只能在表的一端插入、
在另一端删除的线性表
- 能进行插入的一端称为队列尾，简称队尾;
- 能进行删除的一端称为队列头，简称队头
- 在队尾插入元素称为入队(enqueue)，
从队头删除元素称为出队(dequeue)
- 仍然可以沿用线性表的方法来表示队列，
队列Q可以表示为Q=(ao,a1,...,an-1)
- a0称为队头元素，an称为队尾元素，
元素个数n称为队列长度
- 当给定队列的入队序列后，仅能得到一个出队序列，
而且是与入队序列完全相同的序列。
这是由队列先进先出的特性决定的
- 队列中元素的类型是ELEMType，
另外，还有指标队头和队尾的两个量
- 定义如下所示
typedef int ELEMType;
int front,rear;//队头、队尾指针
- 与线性表及栈一样，队列也有两种实现方式，
分别得到顺序队列和链式队列

# 1、顺序队列
使用一个一维数组A(下标从0到n-1)来保存队列，
假定队列中含有m(m≤n)个元素
- 选择A[O]作为队头，那么A[m-1]就是队尾
- 当出队时，队头A[0]从数组中删除，
此时要依次将后面的m-1个元素均前移一个位置，
- 这种情况下出队操作的时间开销是0(m)
# 存储结构
现在交换队头和队尾的位置，
选择A[m-1]是队头，
那么A[0]是队尾-入队时，
队列中原有的m个元素均需后移一个位置，
腾出A[0]的位置放置新元素
此时入队操作的时间开销将为0(m)
- 可以使用变量front指示队头位置，
使用变量rear指示队尾位置
- 称front为队头指针，rear为队尾指针
- 表示的是数组下标
- 通常，front指示的是队头元素所在的位置，
rear指示的是队尾元素后面的空位置
- 按照惯例，还是将第一个入队的元素保存
在数组下标0的位置
- 入队的新元素放置到所有元素的后面
- 经过若干次入队、出队操作后，
含m个元素的队列的示意图如下所示，
其中阴影部分表示队列中的元素
实际占用的数组单元
- 当再进行若干次入队操作后，
rear会到达数组的末尾，即最后一个下标位置。
之后再进行入队操作时，导致数组下标越界。
但数组的前半段可能会因出队操作而有空闲的单元
- 可以重复利用数组中前面的空闲单元保存后续入队的元素

# 循环队列
- 顺序队列都实现为循环队列
- 在循环队列中，入队操作会涉及到队尾rear值的变化，
rear=(rear+1)%n，
出队操作会涉及到队头front值的变化，
front=(front+1)%n，
其中n是数组的大小
- 可以把这个数组想象成一个首尾相接的圆环，
A[n-1]的后面是A[0]
“循环”一词的含义正是如此
# 循环队列的空与满
- 数队满时，rear==front
- 条件rear==front也代表空队列
- 解决方法:让数组中始终剩余至少一个空位置。
当数组中仅有一个空位置时，
就认为已经达到队列的最大长度了，队列已满
- 初始时，front=0且rear=0
# 清空队列
- 队列置空也得到一个空队列，
可以将队头和队尾指针均赋值0，
和初始化队列的结果一样
- 也可以让队头和队尾指针的值相等，
表示是一个空队列
# 判空与判满
- 队列为空的条件是rear==front
- 队列为满的条件是(rear+1)%n==front
# 求队列长度
# 入队与出队

# 2、链式队列
- 链式队列采用带头指针及尾指针的单链表
作为队列的存储结构
- 单链表的头指针可以当作队头指针front，
尾指针可以当作队尾指针rear
# 判空
- 循环队列中，当队头指针和队尾指针相等时，队列为空
- 空链式队列中，队头指针和队尾指针都为NULL
- 在内存足够大的情况下，链式队列通常不会满
# 入队列
# 出队
# 带空闲单元链表的链式队列
- 采用链式方式实现队列时，
也可以配合使用一个空闲单元链表，
使得入队、出队时尽量少地调用maloc函数及free函数，
- 在链式队列中，可以将这两个链表合在一起，
形成一个圆环，即使用一个循环链表来表示链式队列
及对应的空闲单元链表。
在这个循环链表中，结点分为两部分，
一部分结点用来保存实际数据，
另一部分结点是空闲结点
```

#### 进一步讨论栈与队列

```shell
# 双端队列(入队出队同一端)
- 输入受限的双端队列
- 输出受限的双端队列
# 栈与队列的相互模拟
使用栈来模拟队列(双栈)
# 使用队列来模拟栈
队列的特性是先进先出，先进人队列的元素会先退出队列。
但栈的特性是后进先出，所以只使用一个队列不能模拟栈。
设使用队列P和Q来模拟栈S，P作为主队列，Q作为辅助队列。
```

#### 栈和队列的应用

```shell
# 一、括号的匹配检查
程序中有很多符号是成对出现的，
并且它们的出现次序必须正确，
可以嵌套但不能交错“左”符号称为“开”符号，
“右”符号称为“闭”符号
如果表达式中符号匹配正确，
则表达式称为平衡的表达式
可以用栈来实现检验符号平衡性的算法
# 栈的存储及其实现
-从左至右扫描给定的符号串，
忽略所有非括号的符号
- 当遇到开括号时，保存它
- 当遇到一个闭括号时，
看看它是否对应于最近遇到的开括号
- 如果是，则丢掉开括号，并继续扫描符号串
- 如果能扫描完整个符号串，且没有遇到不匹配的情况，
则给定的符号串代表的表达式是平衡的链式存储
- 可以使用栈来保存遇到的开括号 
# 表达式不平衡的情况
- 刚扫描到的闭括号与栈顶开括号不匹配，
说明括号有交错
- 已扫描到表达式尾，但栈不空，
说明开括号数多于闭括号数
- 扫描到闭括号时发现栈为空，
说明缺少与此闭括号对应的开括号
```

```shell
# 二、表达式的计算
# 1、表达式的表示形式及计算次序
- 中缀表达式:<操作数〉〈运算符〉〈操作数>
c*(a+b)
- 前缀表达式<运算符〉<操作数〉<操作数>
- 后缀表达式
<操作数〉<操作数〉<运算符>
# 2、中缀表达式转变为后缀表达式
- 将中缀表达式转变为后缀表达式--手算
- 给中缀表达式中的每个运算符加括号，
这样的表达式称为带完全括号的中缀表达式
- 接下来，将每个运算符右移，
紧贴在对应的闭括号的前面
- 最后，去掉括号得到后缀表达式
- 将中缀表达式转变为后缀表达式--算法
自左至右扫描中缀表达式，当遇到操作数时，直接输出它。
当遇到运算符时，不能像操作数那样直接输出，而是保存在栈中。
当满足一定的条件时才输出栈顶的运算符
- 当读到表达式中的一个运算符时，将它与栈内运算符进行比较。
分以下情况考虑
- 若栈内运算符的优先级高于栈外运算符的优先级，
则输出栈内运算符，
继续比较栈外运算符与栈内运算符
- 若栈外运算符的优先级高于栈内运算符的优先级，
则栈外运算符入栈，继续读入表达式的下一个符号
- 当读到表达式中的一个运算符时，
将它与栈内运算符进行比较。
分以下情况考虑
- 若已经读到表达式末尾，
则依次出栈栈中的全部运算符

# 算法-获取算符优先级
# 3、后缀表达式计算
- 从左至右扫描后缀表达式
- 当遇到操作数时，操作数进栈
- 当遇到运算符时，从栈中弹出两个操作数，
并进行运算符所代表的运算，结果仍放到栈中
- 因为栈的后进先出的特性，
故从栈中先弹出的操作数是
运算符的右操作数，
后弹出的是左操作数
```

```shell
# 打印杨辉三角形
只要保存了前一行的数据，
就可以按规律生成后一行的数据，并输出。
使用循环队列作为存储结构。
初始时队列中保存一个1。
在前一行数据出队的同时，
将后一行的数据依次生成并加入到队列中。
```

## 数组广义表和串

#### 数组及广义表

```shell
# 概念和术语
- 从数据结构的角度来理解，
一维数组可以作为线性表的存储结构，
数组中保存的各元素可以组成一个线性表
- 多维数组在系统内部
都对应一个隐含的一维数组，
所以多维数组也是一种线性表
例如二维数组就是以一维数组为元素的线性表
- 数组的每个元素都是形如(index，value)的二元对，
index是数组下标，也称为索引，
value是对应于该下标的数
- 任何两个元素的index值都不相同
# 数组的基本操作
- Create();//创建一个空的数组
- Store (index, value);//添加数据(index，value)
//同时删除有相同index值的数据对(若存在)
- Retrieve (index);
//返回下标为index的value值
# 数组的顺序存储方式
- 数组的顺序存储有两种形式。
以二维数组为例，它的元素可以按行排列，
也可以按列排列
- 所谓按行排列，就是先排数组的第一行，
紧随其后排第二行，依此类推
- 所谓按列排列，就是先排数组的第一列，
紧随其后排第二列，依此类推
- 最终都是将数组中的全部元素排列成一个序列
# C语言中多维数组
- 下标的形式:[i1][i2][i3]...[ik]
- i(1≤j≤k)为非负整数
- 声明值为整型类型的k维数组DkArray
- int DkArray[u1][u2][u3]... [uk];
- 每一维的下标取值范围:0≤ij<=uj;(1≤j≤k)
- 数组最多可容纳n=u1*u2*u3...*uk个整数
- 所需要的内存空间
- sizeof(DkArray)=nxsizeof(int)个字节
- 若开始地址为start，则占用的空间将延伸至
start+sizeof (DkArray)-1。
# 例
- int D2Array[3][6];对应一个3行6列的矩阵
- 通常int占4个字节
- 数组D2Array中含有18个元素
- 共占用18x4=72个字节
# 编号
- 对上述的下标表格按行自上而下、
同一行中自左至右进行连续编号，从0开始
- 按行优先把二维数组中的下标映射到0到n-1之间
的某个整数的方式称为行主序，也称为行主映射
- 按列优先，对下标表格从第一列开始，
从上到下进行连续编号，直到最后一列
# 映射函数
- 行主序所对应的映射函数为
map(i1,i2)=i1*u2+i2
其中u2是数组的列数
- 列主序所对应的映射函数为
map(i1,i2)=i2*u1+i1
其中u1是数组的行数
- 三维数组D3Array[3][2][4]
- 对于三维数组ThrDimenArray[u1][u2][u3],
其行主序的映射函数应为
map(i1，i2，i3)=i1*u2*u3+i2*u3+i3
排列规律:
- 一维数目:u2*u3

# 矩阵的压缩存储
# 1.对称矩阵和三角矩阵
- 从节省存储空间的角度考虑，
对称矩阵和上(下)三角矩阵，
都可以只保存矩阵中约一半的元素，
从而可以节省差不多一半的存储空间
- 这样的存储形式称为压缩存储
- 对于对称矩阵，因为对角线以上及以下的元素对称相等，
所以只需要保存其中的一半及对角线上的元素即可
- 对于上三角矩阵或下三角矩阵，
仅保存上三角部分或下三角部分的元素，
另外一半的零元素不再保存
- 若矩阵有行列，则这三种形式下
需要保存的元素个数为nx(+1)/2
# 三角部分
- 设以一维数组B[nx(n+1)/2]作为n阶矩阵A的存储结构，
按行主序保存A的下三角部分
- 元素A[i][j](0≤i,j≤n-1)
保存在B[k](0≤k≤n*(n+1)/2一1)，
则k与i,存在下列对应关系:
k=i*(i+1)/2+j   (i>=j)
k=j*(j+1)/2+i   (i<j)
```

#### 串

## 树与二叉树

## 图结构

## 内部排序

## 查找
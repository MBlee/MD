## 绪论

#### 基本概念和术语

```shell
# 数据
是指所有能输入计算机并被计算机程序处理的符号的集合
-数据是各种各样的
-复杂的数据往往由简单的数据构成
-构成数据的基本单位称为数据元素
-数据元素还可以细分为数据项
# 数据结构
数据元素之间的相互关系构成结构，
带有结构特性的数据元素集合构成数据结构
-逻辑结构:指数据元素之间的逻辑关系
-物理结构:指数据结构在计算机中的表示及存储方式
数据的逻辑结构从逻辑上描述数据，
表明数据元素之间的关系是什么样的，这与数据的存储方式无关，
既独立于计算机，也独立于程序设计语言
-数据的最小不可分割的单位是数据项
-逻辑上相关的、具有物理意义的若干数据项构成一个数据元素
-数据元素作为一个完整的对象(整体)是构成数据的基本单位
```

```shell
# 基本数据结构
# 集合:
结构中的数据元素除了“同属于一个集合”外，
没有其它关系
# 线性结构:
结构中的数据元素之间存在一对一的关系
# 树结构:
结构中的数据元素之间存在一对多的关系
# 图结构:
结构中的数据元素之间存在多对多的关系。
```

```shell
# 常用存储方法
# 顺序存储方法:
用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)，
存放地址是连续的。
# 链式存储方法:
用指针来表示数据元素之间的逻辑结构(关系)。
存放地址是否连续没有要求。
# 索引存储方法:
存储结点信息的同时，建立附加的索引表。
索引表由索引项组成
# 散列存储方法:
根据结点的关键字通过散列函数直接计算该结点的存储地址。
```

```shell
# 数据类型
指的是一个值的集合和定义在该值集上的一组操作的总称。
数据类型中定义了两个集合，
-该类型的取值范围，
-该类型中可允许使用的一组运算。
在C语言中数据类型有:
-基本类型:整型，实型，字符型等
-构造类型:数组，结构体等
在高级语言中，
整型类型可能的取值范围是-32768~+32767，
可用的运算符集合为加、减、乘、除、取模(如C语言中+,*,%)。
# 抽象数据类型
-抽象数据类型的定义
包括类型的名字及对各个操作的刻画，
也就是要明确“做什么”
-对于每个操作，要规定操作的名字、
操作执行的前提条件、
输入和输出分别是什么等等。
每个操作通常表示为一个函数或是方法
# 定义格式
ADT<抽象数据类型名>
{数据对象:<数据对象的定义>
结构关系:<结构关系的定义>
基本操作:<基本操作的定义>
}ADT<抽象数据类型名>
ADT Triangle{//三角形的抽象数据类型
定义数据部分:
	a,b,c;//表示构成三角形的三条边，实型
操作部分:
	area(a,b.c)//给定三条边，计算三角形面积
		输入:a,b.c
		输出:三角形的面积
		前提条件:三条边满足构成三角形的条件
	perimeter (a.b,c)//给定三条边，计算三角形周长
		输入:a,b,c
		输出:三角形的周长
		前提条件:三条边满足构成三角形的条件
}ADT Triangle
```

#### 算法和算法分析

```shell
# 算法
是一个由若干确定的(无二义性的)、
可执行的步骤组成的
肯定能够终止的有序步骤集合
算法是描述一个问题的求解过程，
它由一系列解决问题的清晰指令构成
-可以使用自然语言表示
-可以使用计算机程序设计语言表示
-可以混合使用自然语言与计算机程序设计语言
# 例题
将摄氏温标值C转换为华氏温标值F
已知计算公式为:F=(9/5)C+32
转换的过程使用自然语言表示:
输入一个摄氏温标值C
C乘以常数9/5(或1.8)
前一步的乘积与常数32相加，
得到F输出结果F，
即转换后的华氏温标值

转换的过程使用计算机程序设计语言表示:
#include <stdio. h>
int main(int argc,char **argv)
double Ctemp，Ftemp;//分别代表两种温标值
const double fac=1.8, inc=32.0;
printf("输入摄氏温标值:");
Scanf ("%If",&Ctemp);
Ftemp=Ctemp*fac+inc;
printf("摄氏%3.11f 度对应的华氏温标值是:%3.11f\n",Ctemp,Ftemp);
return 0;
# 算法特性
输入:有0或多个输入值
输出:有1或多个输出值
有穷性:一个算法必须在执行有穷步骤之后结束
确定性:算法的每一个步骤必须是有确切含义的
可行性:算法中要做的运算都是相当基本的、能够精确进行的

算法必须要正确，
所以算法的正确性成为评判算法的首要指标
评判算法的其他方面:执行效率
·时间复杂度
·空间复杂度
```

```shell
# 时间复杂度
计算机中最重要的资源之一是CPU，
显然，花费的时间与处理的数据个数有很大的关系，
这个数据个数称为问题规模，也称问题大小。
执行算法花费的时间表示为
问题规模的一个函数
统计一个程序执行期间需要执行的语句总数，
并且约定，
程序设计语言中一条基本语句的执行时间为1个单位时长

一个算法的时间效率可以用问题规模
及关键的处理步骤的多少来定义
将算法的运行效率表示为问题规模n的一个解析式，
对于规模为n的问题，解析式计笑的值，
应该是算法处理的步骤数
将关于n的这个解析式称为增长函数，表示为T(n)
对于一个具体的算法，
其增长函数是一个近似的表达式

# 渐近时间复杂度
考查增长函数时，只关心增长函数表达式中的主项，
并且不再考虑主项的系数
表达式的主项使用记号0来表示
例1.5中增长函数表示为0(n)
例1.6中增长函数表示为O(n2)
这称为渐近时间复杂度，也称为算法的阶

大O表示法和大Q表示法
使我们能够描述某一算法的上限
(如果能找到某一类输入下开销最大的函数)
和下限(如果能找到某一类输入下开销最小的函数)
当上、下限相等时，可用表示法。
如果一种算法既是0(f(n))，
又是Q(f(n))，则称其是(f(n))的
```

```shell
# 常见时间复杂度
-若增长函数不随算法问题规模变化，
则增长函数称为O(1)阶，或称常数复杂度
-与问题规模成正比的问题求解算法称为线性操作
-许多算法具有log2n对数复杂度
-其他的算法有n的某次幂的多项式复杂度，如0(n2)或0(n3)
-更坏的算法是指数复杂度，n是指数，如O(2n) 
```

```shell
# 空间复杂度
除了要评判算法的时间复杂度外，
算法在运行过程中临时占用的空间大小也要考虑，
这称为空间复杂度。
一般地，空间复杂度也表示为问题规模的一个函数。
考虑空间存储量时，算法代码占用的空间、
算法中初始数据占用的存储空间，都不包含在内。
```

#### 算法设计策略简介

```shell
# 设计策略
设计策略有时也可以称为设计方法，
是指在解决特定问题时所采用的一类方法,包括:
递推法、迭代法、递归法、贪心法、分治法、动态规划法等
```

```shell
# 一、递推法
递推法是一种直接求解的算法设计策略，
利用问题本身所具有的一种递推关系进行求解。
找到问题本身的递推关系是问题求解的前提。

递推法的思想是，
根据递推关系，
能从已求得的问题规模为1.2,....i-1的一系列解，
构造出问题规模为i的解。

求解规模为i的解时，
有时可能仅需规模为1.2,...，i-1的系列解中的一部分，
而不是全部
```

```shell
# 二、迭代法
是一种直接求解的方法，
往往需要建立迭代关系式

-即根据前一个值推出下一个值的公式
初始时设定初始值(原值)，
然后根据迭代关系式和原值，求出新值，
并用新值替代原值

迭代过程不能无限进行下去
-或者设定一个迭代次数，
当达到这个次数时迭代过程停止
-或者设定一个结束条件，
当满足这个条件时，迭代过程停止
```

```shell
# 三、递归法
直接或间接地调用自身的算法定义为递归算法;
直接或间接地调用函数本身的函数称为递归函数。
```

```shell
# 四、贪心法
贪心算法也称贪婪算法，
这是一种通过每一步选择局部最优解
来达到整体最优解的算法，
适用于求某些最优解问题

求解过程中，一步一步地进行，
根据当前的情况选择最优的可能

实际上，这个最优是在当前条件下的最优，
称为局部最优
-第四章构造哈夫曼树
-第六章求最小生成树
```

```shell
# 五、分治法
当求解一个输入规模为n并且n的取值又很大的问题时，
可以把这个大规模的问题分解为
若干个规模更小且可以独立求解的问题，
然后把各个小问题的解进行合并，
得到原问题的解。
这就是分治法的思想

一般来说，
分治法的求解过程分为三个阶段
-即划分、求解小问题及小问题解的合并
-第七章的快速排序和归并排序，
将大问题分解为2个小问题进行求解
```

```shell
# 六、动态规划法
动态规划算法是求多阶段决策过程最优化的一种方法，
它将问题的整体按时间或空间的特征分成
若干个前后衔接的阶段，
把多阶段决策问题表示为
前后有关的一系列单阶段决策问题，
然后逐个求解，从而求出
整个问题的最优决策动态规划法
强调了时间和空间的连续性
```

## 线性表

#### 线性表的定义和基本操作

```shell
线性表是一种线性结构。
在这种结构中，
存在着唯一的“第一个”元素、唯一的“第二个”元素，
依此类推。
线性表中各个元素依次排列。
例如，在例1-1中，表1-1列出的某班30名学生的基本信息
能够组成一个线性表，
可以按照学号排列名单。
```

```shell
# 定义
一个线性表(linearlist)是
由同类型数据元素构成的有限序列
由n(n≥0)个元素组成的线性表L，
可以表示为L=(ao,a1,...,an-1)
这里，a(0≤i≤n-1)
即是线性表中的数据元素，也称为表项
# 特点
-线性表中所有数据元素都必须是相同类型的
-数据元素的次序就是它们在表中的排列次序
-第一个元素是a0，称为表头或开始元素
-第n个也即最后一个元素是an-1，称为表尾或终端元素
-元素的个数n称为表长
-n=0时称为空表，记为()

-线性表中常使用非负整数表示各元素的位置
-表头a的位置为0
-a的位置为1
-a;(0≤i≤n-1)的位置为i
-对于元素a;(1≤i≤n-1)，元素a;
(0≤jくi)称为a的前驱，
其中元素a称为a的直接前驱(可简称为前驱)
-对于元素a;(0≤i≤n-2)，
元素aj(i<j≤n-1)称为a;的后继，
其中元素a称为a;的直接后继(可简称为后继)
```

```shell
# 例1
将例1-1的学生基本信息表表示为线性表Student
Student=
((M2022103001 王义平男2004.11.22 山东)，
(M2022103002陆东男2004.02.05河南)，...，
(M2022103030 杨志强男2004.10.30 陕西))
```

#### 线性表的顺序存储及实现

```shell
-操作的具体实现需要依赖于线性表的存储结构
-顺序存储结构使用数组保存线性表中的各元素，
相应的线性表称为顺序表
-链式存储结构使用链表保存线性表中的各元素，
相应的线性表称为链表
```

```shell
# 顺序表
- 顺序存储的基本思想是
使用一组连续的存储单元依次存储各个元素，
将线性表中的各数据元素，按照其逻辑次序，
依次保存在数组的各个单元中
- 线性表中逻辑上相邻的两个元素，
保存在数组相邻的两个单元中，
分配一个多大的数组是个挑战
- 数组是内存中一片连续的空间，
相邻的两个单元在内存中的实际地址也是相邻的，
这表明，线性表中逻辑上相邻的两个元素，
其存储地址也是相邻的

- 数组下标与线性表元素的位置相对应
- 线性表元素依次存放的特性，
决定着表中元素i(i≥0)存储在数组的下标i处
- 表头元素保存在位置0处，
这个位置也称为数组的首地址
- 只要给定数组下标，
就能立即计算出相应元素的存储地址，
并据此访问该元素
# 地址计算
设L0C(a)表示元素a的存储首地址，
每个元素需占用d个存储单元，则有:
L0C(ai)=L0C(ai-1)+d进一步地有:
L0C(ai)=L0C(a0)+ixd
LOC(a0)即是数组的首地址
```

```shell
# 顺序表的插入删除
设给定一个顺序表，
初始时含有5个元素。
在位置2插入元素27，
然后删除位置3的元素
```

```c
// 顺序表的定义
typedef int ELEMType;
typedef struct{
    ELEMType element[maxSize];//保存元素的数组，最大容量为maxSize
    int n;//顺序表中的元素个数
}SeqList
typedef SeqList LinearList;
typedef int Position;
// 查找
Position find(SeqList *L,ELEMType x)//返回元素x在表L中第一次出现的位置
int i;
for(i=0;i<L->n;i++)
    if(L->element[i]==x)
        return i;
	return ERROR;//表示未找到

// 构造空表及清空表
int initList(SeqList *L)//初始化顺序表，创建一个空表L
	L->n=0;
	return TRUE;
int clear(SeqList *L)//将表L置空
    L->n=0;
	return TRUE;

// 判表空、判表满、求表长
int isEmpty(SeqList*L)//如果表L为空则返回1，否则返回0
	if(L->n--0) return TRUE;
	else return FALSE;
int isFull(SeqList*L)//如果表L已满则返回1，否则返回0
	if(L->n--maxSize) return TRUE;
	else return FALSE;
int length(SeqList*L)//返回表L的当前长度
	return L->n;

// 插入新元素
// 插入操作中移动元素的平均次数为n/2
int insertList(SeqList *L,Position pos,ELEMType x)
    //在表L的位置pos处插入元素x
	inti:
	if(isFull(L)-=TRUE) return FALSE;//表已满
	if(pos<0||pos>L->n) return ERROR;//位置错误，与表满区别开
	for(i=L->n;i>pos;i--)
        L->element[i]=L->element[i-1];//移动元素
	L->element[i]=x;//放置x
	L->n++;
	return TRUE;//表长增1

// 删除操作
// 删除操作中移动元素的平均次数为(~1)/2
int removeList(SeqList *L,Position pos,ELEMType *x)
    //删除表L中位置pos处的元素并通过x返回
	inti:
	if(isEmpty(L)==TRUE) return FALSE;//表空
	if(pos<0||pos>L->n-1) return ERROR;//位置错误，与表空区别开
	*x=L->element[pos];//记下被删除的元素值
	for(i-pos;i<L->n-1;i++)
        L->element[i]=L->element[i+1]://前移元素
	L->n-;//表长减1
	return TRUE;

// 赋值、取值操作
int set Value(SeqList *L,Position pos,ELEMType x)
    //给表L位置pos处的元素赋值x
	if(pos>=0&&pos<L->n)
    	L->element[pos]=x;return TRUE;
	return FALSE;
int getValue(SeqList *L,Position pos,ELEMType *x)
    //返回表L中位置pos处的元素
	if(pos>=0&&pos<L->n)
        *x=L->element[pos];
		return TRUE;
	return FALSE;

// 示例 例2-5
设有顺序表L，表长为n，保存在数组A中。实现算法将L逆置，
即L=(a0, a1, ..., an-2, an-1
变为L=(an-1, an-2, ..., a1, a)
将A[0]与A[n-1]进行交换，
然后将A[1]与A[n-2]进行交换，依此类推，
当交换到中间元素时，算法结束
```

#### 线性表的链式存储及实现

```shell
# 链式存储方式:
线性表中的各个元素
保存在各自的存储空间中，
形成一个个的结点
这些结点在内存中的地址不要求是相邻的，
它们之间通过指针连接起来，
以这种方式保存的线性表称为链表
# 循环链表
-修改单链表的定义，
将表尾结点的指针指回头结点，
从而形成一类新链表
-这样的链表中，从任何一个结点出发
沿着指针域的指示可以再回到这个结点，
好象转了一个圈一样，
形象地称这样的链表为循环链表
```

```shell
# 单向链表
# 双向链表
# 双向循环链表
```

#### 进一步讨论两种基本实现方式

```shell
# 线性表有两种基本的实现方式:分别是顺序实现和链式实现
- 顺序表存储每个数据元素时空间比较紧凑，
并且是占用连续的空间
- 数组的每个单元中只需要保存数据本身，
没有额外的开销
- 链表在每个结点上除存储数据元素外，
还要留出空间存放指针。
单链表中每个结点包含一个指针，
双向链表中每个结点包含两个指针。
这些指针占用的空间称为结构性开销
```

#### 单链表的应用

```shell
# 
```

```shell
# 
```

```shell
# 
```

## 栈和队列

## 数组广义表和串

## 树与二叉树

## 图结构

## 内部排序

## 查找
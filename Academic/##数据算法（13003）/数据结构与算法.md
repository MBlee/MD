## 绪论

#### 基本概念和术语

```shell
# 数据
是指所有能输入计算机并被计算机程序处理的符号的集合
-数据是各种各样的
-复杂的数据往往由简单的数据构成
-构成数据的基本单位称为数据元素
-数据元素还可以细分为数据项
# 数据结构
数据元素之间的相互关系构成结构，
带有结构特性的数据元素集合构成数据结构
-逻辑结构:指数据元素之间的逻辑关系
-物理结构:指数据结构在计算机中的表示及存储方式
数据的逻辑结构从逻辑上描述数据，
表明数据元素之间的关系是什么样的，这与数据的存储方式无关，
既独立于计算机，也独立于程序设计语言
-数据的最小不可分割的单位是数据项
-逻辑上相关的、具有物理意义的若干数据项构成一个数据元素
-数据元素作为一个完整的对象(整体)是构成数据的基本单位
```

```shell
# 基本数据结构
# 集合:
结构中的数据元素除了“同属于一个集合”外，
没有其它关系
# 线性结构:
结构中的数据元素之间存在一对一的关系
# 树结构:
结构中的数据元素之间存在一对多的关系
# 图结构:
结构中的数据元素之间存在多对多的关系。
```

```shell
# 常用存储方法
# 顺序存储方法:
用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构(关系)，
存放地址是连续的。
# 链式存储方法:
用指针来表示数据元素之间的逻辑结构(关系)。
存放地址是否连续没有要求。
# 索引存储方法:
存储结点信息的同时，建立附加的索引表。
索引表由索引项组成
# 散列存储方法:
根据结点的关键字通过散列函数直接计算该结点的存储地址。
```

```shell
# 数据类型
指的是一个值的集合和定义在该值集上的一组操作的总称。
数据类型中定义了两个集合，
-该类型的取值范围，
-该类型中可允许使用的一组运算。
在C语言中数据类型有:
-基本类型:整型，实型，字符型等
-构造类型:数组，结构体等
在高级语言中，
整型类型可能的取值范围是-32768~+32767，
可用的运算符集合为加、减、乘、除、取模(如C语言中+,*,%)。
# 抽象数据类型
-抽象数据类型的定义
包括类型的名字及对各个操作的刻画，
也就是要明确“做什么”
-对于每个操作，要规定操作的名字、
操作执行的前提条件、
输入和输出分别是什么等等。
每个操作通常表示为一个函数或是方法
# 定义格式
ADT<抽象数据类型名>
{数据对象:<数据对象的定义>
结构关系:<结构关系的定义>
基本操作:<基本操作的定义>
}ADT<抽象数据类型名>
ADT Triangle{//三角形的抽象数据类型
定义数据部分:
	a,b,c;//表示构成三角形的三条边，实型
操作部分:
	area(a,b.c)//给定三条边，计算三角形面积
		输入:a,b.c
		输出:三角形的面积
		前提条件:三条边满足构成三角形的条件
	perimeter (a.b,c)//给定三条边，计算三角形周长
		输入:a,b,c
		输出:三角形的周长
		前提条件:三条边满足构成三角形的条件
}ADT Triangle
```

#### 算法和算法分析

```shell
# 算法
是一个由若干确定的(无二义性的)、
可执行的步骤组成的
肯定能够终止的有序步骤集合
算法是描述一个问题的求解过程，
它由一系列解决问题的清晰指令构成
-可以使用自然语言表示
-可以使用计算机程序设计语言表示
-可以混合使用自然语言与计算机程序设计语言
# 例题
将摄氏温标值C转换为华氏温标值F
已知计算公式为:F=(9/5)C+32
转换的过程使用自然语言表示:
输入一个摄氏温标值C
C乘以常数9/5(或1.8)
前一步的乘积与常数32相加，
得到F输出结果F，
即转换后的华氏温标值

转换的过程使用计算机程序设计语言表示:
#include <stdio. h>
int main(int argc,char **argv)
double Ctemp，Ftemp;//分别代表两种温标值
const double fac=1.8, inc=32.0;
printf("输入摄氏温标值:");
Scanf ("%If",&Ctemp);
Ftemp=Ctemp*fac+inc;
printf("摄氏%3.11f 度对应的华氏温标值是:%3.11f\n",Ctemp,Ftemp);
return 0;
# 算法特性
输入:有0或多个输入值
输出:有1或多个输出值
有穷性:一个算法必须在执行有穷步骤之后结束
确定性:算法的每一个步骤必须是有确切含义的
可行性:算法中要做的运算都是相当基本的、能够精确进行的

算法必须要正确，
所以算法的正确性成为评判算法的首要指标
评判算法的其他方面:执行效率
·时间复杂度
·空间复杂度
```

```shell
# 时间复杂度
计算机中最重要的资源之一是CPU，
显然，花费的时间与处理的数据个数有很大的关系，
这个数据个数称为问题规模，也称问题大小。
执行算法花费的时间表示为
问题规模的一个函数
统计一个程序执行期间需要执行的语句总数，
并且约定，
程序设计语言中一条基本语句的执行时间为1个单位时长

一个算法的时间效率可以用问题规模
及关键的处理步骤的多少来定义
将算法的运行效率表示为问题规模n的一个解析式，
对于规模为n的问题，解析式计笑的值，
应该是算法处理的步骤数
将关于n的这个解析式称为增长函数，表示为T(n)
对于一个具体的算法，
其增长函数是一个近似的表达式

# 渐近时间复杂度
考查增长函数时，只关心增长函数表达式中的主项，
并且不再考虑主项的系数
表达式的主项使用记号0来表示
例1.5中增长函数表示为0(n)
例1.6中增长函数表示为O(n2)
这称为渐近时间复杂度，也称为算法的阶

大O表示法和大Q表示法
使我们能够描述某一算法的上限
(如果能找到某一类输入下开销最大的函数)
和下限(如果能找到某一类输入下开销最小的函数)
当上、下限相等时，可用表示法。
如果一种算法既是0(f(n))，
又是Q(f(n))，则称其是(f(n))的
```

```shell
# 常见时间复杂度
-若增长函数不随算法问题规模变化，
则增长函数称为O(1)阶，或称常数复杂度
-与问题规模成正比的问题求解算法称为线性操作
-许多算法具有log2n对数复杂度
-其他的算法有n的某次幂的多项式复杂度，如0(n2)或0(n3)
-更坏的算法是指数复杂度，n是指数，如O(2n) 
```

```shell
# 空间复杂度
除了要评判算法的时间复杂度外，
算法在运行过程中临时占用的空间大小也要考虑，
这称为空间复杂度。
一般地，空间复杂度也表示为问题规模的一个函数。
考虑空间存储量时，算法代码占用的空间、
算法中初始数据占用的存储空间，都不包含在内。
```

#### 算法设计策略简介

```shell
# 设计策略
设计策略有时也可以称为设计方法，
是指在解决特定问题时所采用的一类方法,包括:
递推法、迭代法、递归法、贪心法、分治法、动态规划法等
```

```shell
# 一、递推法
递推法是一种直接求解的算法设计策略，
利用问题本身所具有的一种递推关系进行求解。
找到问题本身的递推关系是问题求解的前提。

递推法的思想是，
根据递推关系，
能从已求得的问题规模为1.2,....i-1的一系列解，
构造出问题规模为i的解。

求解规模为i的解时，
有时可能仅需规模为1.2,...，i-1的系列解中的一部分，
而不是全部
```

```shell
# 二、迭代法
是一种直接求解的方法，
往往需要建立迭代关系式

-即根据前一个值推出下一个值的公式
初始时设定初始值(原值)，
然后根据迭代关系式和原值，求出新值，
并用新值替代原值

迭代过程不能无限进行下去
-或者设定一个迭代次数，
当达到这个次数时迭代过程停止
-或者设定一个结束条件，
当满足这个条件时，迭代过程停止
```

```shell
# 三、递归法
直接或间接地调用自身的算法定义为递归算法;
直接或间接地调用函数本身的函数称为递归函数。
```

```shell
# 四、贪心法
贪心算法也称贪婪算法，
这是一种通过每一步选择局部最优解
来达到整体最优解的算法，
适用于求某些最优解问题

求解过程中，一步一步地进行，
根据当前的情况选择最优的可能

实际上，这个最优是在当前条件下的最优，
称为局部最优
-第四章构造哈夫曼树
-第六章求最小生成树
```

```shell
# 五、分治法
当求解一个输入规模为n并且n的取值又很大的问题时，
可以把这个大规模的问题分解为
若干个规模更小且可以独立求解的问题，
然后把各个小问题的解进行合并，
得到原问题的解。
这就是分治法的思想

一般来说，
分治法的求解过程分为三个阶段
-即划分、求解小问题及小问题解的合并
-第七章的快速排序和归并排序，
将大问题分解为2个小问题进行求解
```

```shell
# 六、动态规划法
动态规划算法是求多阶段决策过程最优化的一种方法，
它将问题的整体按时间或空间的特征分成
若干个前后衔接的阶段，
把多阶段决策问题表示为
前后有关的一系列单阶段决策问题，
然后逐个求解，从而求出
整个问题的最优决策动态规划法
强调了时间和空间的连续性
```

## 线性表

#### 线性表的定义和基本操作

```shell
线性表是一种线性结构。
在这种结构中，
存在着唯一的“第一个”元素、唯一的“第二个”元素，
依此类推。
线性表中各个元素依次排列。
例如，在例1-1中，表1-1列出的某班30名学生的基本信息
能够组成一个线性表，
可以按照学号排列名单。
```

```shell
# 定义
一个线性表(linearlist)是
由同类型数据元素构成的有限序列
由n(n≥0)个元素组成的线性表L，
可以表示为L=(ao,a1,...,an-1)
这里，a(0≤i≤n-1)
即是线性表中的数据元素，也称为表项
# 特点
-线性表中所有数据元素都必须是相同类型的
-数据元素的次序就是它们在表中的排列次序
-第一个元素是a0，称为表头或开始元素
-第n个也即最后一个元素是an-1，称为表尾或终端元素
-元素的个数n称为表长
-n=0时称为空表，记为()

-线性表中常使用非负整数表示各元素的位置
-表头a的位置为0
-a的位置为1
-a;(0≤i≤n-1)的位置为i
-对于元素a;(1≤i≤n-1)，元素a;
(0≤jくi)称为a的前驱，
其中元素a称为a的直接前驱(可简称为前驱)
-对于元素a;(0≤i≤n-2)，
元素aj(i<j≤n-1)称为a;的后继，
其中元素a称为a;的直接后继(可简称为后继)
```

```shell
# 例1
将例1-1的学生基本信息表表示为线性表Student
Student=
((M2022103001 王义平男2004.11.22 山东)，
(M2022103002陆东男2004.02.05河南)，...，
(M2022103030 杨志强男2004.10.30 陕西))
```

#### 线性表的顺序存储及实现

```shell
-操作的具体实现需要依赖于线性表的存储结构
-顺序存储结构使用数组保存线性表中的各元素，
相应的线性表称为顺序表
-链式存储结构使用链表保存线性表中的各元素，
相应的线性表称为链表
```

```shell
# 顺序表
- 顺序存储的基本思想是
使用一组连续的存储单元依次存储各个元素，
将线性表中的各数据元素，按照其逻辑次序，
依次保存在数组的各个单元中
- 线性表中逻辑上相邻的两个元素，
保存在数组相邻的两个单元中，
分配一个多大的数组是个挑战
- 数组是内存中一片连续的空间，
相邻的两个单元在内存中的实际地址也是相邻的，
这表明，线性表中逻辑上相邻的两个元素，
其存储地址也是相邻的

- 数组下标与线性表元素的位置相对应
- 线性表元素依次存放的特性，
决定着表中元素i(i≥0)存储在数组的下标i处
- 表头元素保存在位置0处，
这个位置也称为数组的首地址
- 只要给定数组下标，
就能立即计算出相应元素的存储地址，
并据此访问该元素
# 地址计算
设L0C(a)表示元素a的存储首地址，
每个元素需占用d个存储单元，则有:
L0C(ai)=L0C(ai-1)+d进一步地有:
L0C(ai)=L0C(a0)+ixd
LOC(a0)即是数组的首地址
```

```shell
# 顺序表的插入删除
设给定一个顺序表，
初始时含有5个元素。
在位置2插入元素27，
然后删除位置3的元素
```

```c
// 顺序表的定义
typedef int ELEMType;
typedef struct{
    ELEMType element[maxSize];//保存元素的数组，最大容量为maxSize
    int n;//顺序表中的元素个数
}SeqList
typedef SeqList LinearList;
typedef int Position;
// 查找
Position find(SeqList *L,ELEMType x)//返回元素x在表L中第一次出现的位置
int i;
for(i=0;i<L->n;i++)
    if(L->element[i]==x)
        return i;
	return ERROR;//表示未找到

// 构造空表及清空表
int initList(SeqList *L)//初始化顺序表，创建一个空表L
	L->n=0;
	return TRUE;
int clear(SeqList *L)//将表L置空
    L->n=0;
	return TRUE;

// 判表空、判表满、求表长
int isEmpty(SeqList*L)//如果表L为空则返回1，否则返回0
	if(L->n--0) return TRUE;
	else return FALSE;
int isFull(SeqList*L)//如果表L已满则返回1，否则返回0
	if(L->n--maxSize) return TRUE;
	else return FALSE;
int length(SeqList*L)//返回表L的当前长度
	return L->n;

// 插入新元素
// 插入操作中移动元素的平均次数为n/2
int insertList(SeqList *L,Position pos,ELEMType x)
    //在表L的位置pos处插入元素x
	inti:
	if(isFull(L)-=TRUE) return FALSE;//表已满
	if(pos<0||pos>L->n) return ERROR;//位置错误，与表满区别开
	for(i=L->n;i>pos;i--)
        L->element[i]=L->element[i-1];//移动元素
	L->element[i]=x;//放置x
	L->n++;
	return TRUE;//表长增1

// 删除操作
// 删除操作中移动元素的平均次数为(~1)/2
int removeList(SeqList *L,Position pos,ELEMType *x)
    //删除表L中位置pos处的元素并通过x返回
	inti:
	if(isEmpty(L)==TRUE) return FALSE;//表空
	if(pos<0||pos>L->n-1) return ERROR;//位置错误，与表空区别开
	*x=L->element[pos];//记下被删除的元素值
	for(i-pos;i<L->n-1;i++)
        L->element[i]=L->element[i+1]://前移元素
	L->n-;//表长减1
	return TRUE;

// 赋值、取值操作
int set Value(SeqList *L,Position pos,ELEMType x)
    //给表L位置pos处的元素赋值x
	if(pos>=0&&pos<L->n)
    	L->element[pos]=x;return TRUE;
	return FALSE;
int getValue(SeqList *L,Position pos,ELEMType *x)
    //返回表L中位置pos处的元素
	if(pos>=0&&pos<L->n)
        *x=L->element[pos];
		return TRUE;
	return FALSE;

// 示例 例2-5
设有顺序表L，表长为n，保存在数组A中。实现算法将L逆置，
即L=(a0, a1, ..., an-2, an-1
变为L=(an-1, an-2, ..., a1, a)
将A[0]与A[n-1]进行交换，
然后将A[1]与A[n-2]进行交换，依此类推，
当交换到中间元素时，算法结束
```

#### 线性表的链式存储及实现

```shell
# 链式存储方式:
线性表中的各个元素
保存在各自的存储空间中，
形成一个个的结点
这些结点在内存中的地址不要求是相邻的，
它们之间通过指针连接起来，
以这种方式保存的线性表称为链表
# 循环链表
-修改单链表的定义，
将表尾结点的指针指回头结点，
从而形成一类新链表
-这样的链表中，从任何一个结点出发
沿着指针域的指示可以再回到这个结点，
好象转了一个圈一样，
形象地称这样的链表为循环链表
```

```shell
# 单向链表
# 双向链表
# 双向循环链表
```

#### 进一步讨论两种基本实现方式

```shell
# 线性表有两种基本的实现方式:分别是顺序实现和链式实现
- 顺序表存储每个数据元素时空间比较紧凑，
并且是占用连续的空间
- 数组的每个单元中只需要保存数据本身，
没有额外的开销
- 链表在每个结点上除存储数据元素外，
还要留出空间存放指针。
单链表中每个结点包含一个指针，
双向链表中每个结点包含两个指针。
这些指针占用的空间称为结构性开销
- 为顺序表分配的数组，通常要宽松一些。
通常数组中会有空闲的空间，
此时并没能充分利用数组的全部空间
- 链表中占用的空间大小与链表中的元素个数成正比，
分配的结点是全部使用的
- 当线性表的元素个数相对较少时，
链表的实现比顺序表的实现更节省空间
- 当线性表中的元素个数接近分配的最大个数，
数组的空间存储效率很高
```

```shell
设n表示线性表中当前元素的个数，
D表示最多可以在数组中存储的元素个数，
也就是数组的大小，
P表示指针的存储单元大小，
E表示数据元素的存储单元大小
顺序表的空间需求为DXE
单链表的空间需求为nX(P+E)
n的临界值n=DXE/(P+E)
双向链表比单链表中每个结点的指针数多1个。
所以双向链表的结构性开销是单链表的2倍
```

```shell
# 例1
设保存线性表L的每个元素需要的空间为10个字节，
指针占2个字节。
若采用单链表或含30个元素的数组保存L。
试分析采用哪种方式空间存储效率更高?
(仅需要考虑L中元素)
根据题意，采用单链表保存L时，
每个结点占用的空间为12个字节。

- 如果采用数组保存，
则需要的空间是30X10=300个字节。
使用这些空间保存单链表中的结点的话，
可以保存300/12=25个结点
- 在不考虑表头结点占用的空间的前提下，
如果L中元素个数少于25个，
则采用单链表更省空间
- 如果多于25个元素，
则采用数组更省空间
- 如果正好是25个元素，
则单链表和数组占用的空间是一样大的
```

```shell
# 如何选择
- 当线性表元素个数变化较大或者未知时，
最好使用链表实现
- 如果用户事先知道线性表的大致长度，
则使用顺序表的空间效率会更高些
- 还要考虑到，顺序表占用的空间是连续的，
而链表占用的空间可能是零散的，
并且还需要程序员来管理空间的分配及释放
- 操作的时间复杂度也要考虑
# 复杂度差异
- 在顺序表中是直接定位的，
可以实现随机访问，
操作的时间复杂度是0(1)
- 单链表不能随机访问指定的元素，
平均时间复杂度和最差时间复杂度均为0(n)
- 在给出指向链表的当前指针后，
在单链表内进行插入和删除操作的时间复杂度也可以达到0(1)
- 顺序表的插入和删除操作，
平均和最差时间复杂度均为0(n)
```

```shell
# 二、空闲单元链表
- 链表中，当需要在链表中插入一个结点时，
需要调用maloc函数分配相应的空间
- 当在链表中删除一个结点时，
需要调用delete函数释放空间。
如果在链表中频繁进行插入、删除结点的操作，
则频繁调用这些函数的时间开销会是非常可观的
- 可以针对实际应用的每类链表，
定义一个“伙伴链表”，
表结点的结构与所使用的链表结构一致
- 伙伴链表用来管理暂时不用的结点，
可以将伙伴链表称为空闲单元链表
- 当从链表L中删除一个结点时，
将这个结点插入到freelist中
- 当需要申请新的结点空间时，
先查看链表freelist。
如果freelist不空，
则从freelist中获取一个结点，
结点中保存相应的值，
并将该结点插入到L的相应位置，
否则调用maloc函数分配新的空间，
并完成后续的插入操作
```

```shell
# 三、静态链表
# 静态链表的特点
- 保存在数组中
- 兼具顺序表和链表特性，空间不零碎，
插入删除不需要移动元素
# 静态链表的操作
在前一个静态链表中插入元素E后的静态链表
```

#### 单链表的应用

```shell
# 一、查找单链表倒数第k个结点
如果知道了单链表的长度，
那么访问倒数第k个结点就很容易了。
假设单链表长度为n，
则倒数第k个结点即是第n-k+1个结点

- 使用两个指针front和rear，
均从表头开始同步向表尾方向移动
- 初始时，先令front前进k步，当个“排头兵”
- 这样front和rear指向的位置相距k个结点
- 然后两个指针同步前进
- 当front到达表尾时，rear即位于倒数第k个结点
```

```shell
# 二、查找单链表的中间结点
使用两个指针，
并同时从表头开始向表尾方向移动，
一个指针一次走两步，
另一个指针一次走一步。
这样，当“排头兵”指针到达表尾时，
后面的指针即指向链表的中间结点。
与findKth函数中一样，
两个指针分别是front和rear
```

```shell
# 三、将单链表逆置
- 使用3个指针分别指向相邻的三个结点，
接下来让middle所指结点的next域指向left所指结点，
即left所指结点的原后继(middle所指)变为它的新前驱。
然后，三个指针依次后移一个位置
- 当所有结点中的next域都转向后，
再将head所指的头结点链接在表头处
```

## 栈和队列

#### 栈

```shell
# 一、栈的定义及其基本操作
栈(stack)是限定仅在一端进行插入和删除的线性表
能进行插入和删除的这一端称为栈顶，
线性表的另一端称为栈底在栈顶
插入一个元素称为入栈(push)、进栈或压栈，
从栈顶删除一个元素称为出栈(pop)或退栈
# 栈的表示
将栈S表示为:S=(a,a,..,an-1)
通常指定an1一端为栈顶，
a0一端是栈底
栈中元素个数n称为栈的长度，
当n=0时，称为空栈
# 栈的特点
栈具有后进先出(LIFO，Last In FirstOut)的特性
- 只要栈不空，就允许出栈
- 只要栈不满，就允许入栈
- 当没有其他的特殊限制时，
对于同一个入栈序列，
可能会得到很多个合理正确的出栈序列
```

```shell
# 二、栈的存储及其实现
栈有两种主要的存储方式
- 顺序存储
- 链式存储
- 顺序存储方式使用数组保存栈元素，
得到的是顺序栈
- 链式存储方式使用单链表保存栈元素，
得到的是链式栈
# 1、顺序栈及其实现
- 在顺序栈中，
栈中的元素保存在一维数组中，
将栈底定义在数组下标为0的位置
- 同时使用一个变量标记栈顶的位置，
即栈顶位置
- 栈顶位置也称为栈顶指针
# 效率
- top的值既是保存下一个入栈元素的位置，
也是栈中所含元素个数的计数器
- 因为栈的入栈操作及出栈操作都在栈顶进行，
所以入栈、出栈、获取栈顶元素
时都不需要移动栈中已有的元素，
故时间复杂度都是0(1)
- 判定栈空及栈满等操作的时间复杂度也是0(1)

# 对顶栈
- 数组的两个端点分别作为两个栈的栈底
- 左侧栈占用数组0到k的单元，栈顶在k+1位置
- 右侧栈占用数组m-1到h的单元，栈顶在h-1位置
- 此时必须满足kh，才能保证两个栈不会重叠
- 栈S1入栈时，栈顶值增大，出栈时栈顶值减小
- 栈S2刚好相反，入栈时栈顶值减小，出栈时栈顶值增大

# 2、链式栈
所谓的链式栈，
- 可以看作是一个仅在表头位置进行操作的单链表
- 将头指针所指的这一端作为栈顶，表尾一端作为栈底
- 入栈操作及出栈操作都可以通过头指针完成。
所以，在链式栈中，可以只定义头指针，
尾指针及头结点都可以不定义
# 初始化
栈初始时是个空栈，所以指向栈顶的指针赋值NULL
# 出栈
- 仅当栈不为空时才能执行出栈操作，
所以pop函数中要先判断栈不为空
- 出栈后，将栈顶元素的值通过x返回给调用者
- 元素所占用的空间要释放掉
# 入栈
入栈时，需要创建一个新结点，
并将新结点插入在栈顶位置

# 3、顺序栈与链式栈的比较
- 实现顺序栈和链式栈的所有操作都只需要常数时间，
因此栈的两种实现方式的优劣
仅体现在它们的存储效率上
- 顺序栈需要预先申请一个固定长度的一维数组，
并自始至终全部占用，当栈中元素个数相对较少时，
空间浪费较大
- 链式栈的长度虽然可变，但是每个元素都需要一个指针域，
这又产生了结构性空间开销
- 栈是保存调用信息的最佳结构
- 系统内部会开辟一个函数调用栈用来保存函数
在调用过程中所需要的一些信息
```



#### 队列

#### 进一步讨论栈与队列

#### 栈和队列的应用

## 数组广义表和串

## 树与二叉树

## 图结构

## 内部排序

## 查找
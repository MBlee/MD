## 算法设计策略

```shell
# 一、递推法
- 直接求解
- 递推关系(问题规模部分)
```

```shell
# 二、迭代法
- 直接求解
- 迭代关系式(前值/后值)
- 迭代次数/迭代条件
```

```shell
# 三、递归法
```

```shell
# 四、贪心法
```

```shell
# 五、分治法
```

```shell
# 六、动态规划法
```

## 线性表

```shell
### 线性表定义
- 同类型数据元素
- 有限序列
- (表项-表长-表头-表尾-前驱-后驱-空表)
# 线性表基本操作
- 查(索引/长度/元素)
- 增删改(索引/元素)
# 存储结构
- 顺序存储结构(数组/顺序表)
- 链表存储结构(链表)
```

```shell
### 顺序表
- 连续的存储单元(依次存储)
- 逻辑相邻(存储地址相邻)
- (下标/首地址/存储地址)
# 插入删除
- 插入(移动元素平均次数为n/2)
- 删除(移动元素平均次数(n-1)/2)
- 逆置(头尾交换->中间)
```

```shell
### 链表
- 结点(各元素/各存储空间)
- 指针域/数据域
- 循环
# 单链表
- 动态分配节点
- 元素和指针(指向后驱)
- 头节点(空表标志/表长)
# 插入删除
- 创建节点
- 节点指针(前后)
# 双向链表
# 插入删除
- 创建节点
- 节点指针(后前)
```

```shell
### 两种方式对比
- 顺序表元素空间(紧凑/连续)
- 数组每单元(数据/没有额外)
- 链表(数据/指针结构性开销/单双)
- 数组宽松(空闲空间)
- 链表空间元素个数正比(全部)
- 元素少(链表更节省)
- 元素大(数组存储效率高)
- 结构性开销(双单2倍)
# 如何选择
- 个数变化大或未知,链表
- 知道大致长度,顺序表
- 连续/零散,需要分配释放
- 操作时间复杂度
# 复杂度差异
- 顺序表直接定位(随机访问),O(1)
- 单链表不能随机访问,平均和最差均为O(n)
- 给出指针,插入删除可O(1)
- 顺序表插入删除,平均和最差均为O(n)
# 例1
设n元素个数,D最多个数,P指针大小,E数据大小
顺序表:D*E
单链表:n*(P+E)
n临界值:n=D*E/(P+E)
双是单2倍
# 例2
设L每个元素空间10字节,指针2字节
用单链表或含30元素数组保存L
哪种空间存储率更高?仅考虑L元素
- 单链表节点12字节
- 数组空间30*10=300,单链表300/12=25
- 不考虑表头节点,少于25,单链表
- 多于25,数组
- 等于25,一样大
```

```shell
# 空闲单链表
- 插入删除malloc/delete,开销可观
- 伙伴链表,结构一致(管理暂时不用的节点)
- 删除节点,插入freelist
- 申请节点,从freelist获取,保存插入,否则malloc
# 静态链表特点
- 保存在数组中
- 兼具顺序表链表特性,空间不零碎,
插入删除不需要移动元素
# 静态链表操作
- 插入删除(直接)
```

```shell
### 单链表应用
# 查找单链表倒数第k个节点
- n-k+1, front/rear
- 初始front前进k步
- 然后同步前进
- front表尾,rear为倒数k
```

## 栈和队列

```shell
### 栈的定义及其基本操作
- 限定一端插入删除
- 栈顶/栈底
- 入栈/出栈
- S=(a0,a1,...an-1)
# 栈特点
- 后进先出
- 栈不空出栈
- 栈不满入栈
- 同一入栈序列,多个出栈序列
# 例1
设1,2,3,4,5入栈,
得到2,1,4,3,5
操作过程:
push(1),push(2)
pop(2),pop(1)
push(3),push(4)
pop(4),pop(3)
push(5),pop(5)
```

```shell
### 二、栈的存储及其实现
- 顺序栈(数组)
- 链式栈(单链表)

# 1.顺序栈
- 一维数组
- 栈底(0)栈顶(top)
# 入栈
- 新元素放top,top++
- 第一个放0
- 最大容量maxsize(是否满)
# 出栈
- --top,x=elment[top]
- 是否空
# 效率
- top(计数器/入栈位置)
- 入栈/出栈/获取栈顶不需移动(O(1))
- 判定栈空栈满O(1)
# 对顶栈
- 两端点两栈底
- 左栈0到k,栈顶k+1
- 右栈m-1到h,栈顶h-1
- 必须k<h(不会重叠)
- S1入栈,栈顶值增大,出栈栈顶值减小
- S2相反

# 2.链式栈
- 仅表头操作得单链表
- 头指针(栈顶),表尾(栈底)
- 头指针(入栈出栈)
# 出栈
- 不空出栈
- 栈顶返回x
- 释放元素空间
# 入栈
- 创建新结点,插入栈顶

# 顺序栈与链式栈比较
- 操作常数时间(存储效率)
- 顺序栈预申请固定长度数组(少时,浪费大)
- 链式栈长度可变,有指针域(结构性空间开销)

# 栈与函数调用
- 保存调用信息(最佳结构)
- 系统开辟函数调用栈(调用所需信息)
```

```shell
### 队列
- 特殊线性表(操作位置)
- 优先(先来先服务)(先进先出)
# 定义
- 一端插入/另一端删除的线性表
- 队列尾(插入)/队列头(删除)
- 入队/出队
- Q=(a0,a1,..an-1)
- 队头元素/队尾元素/队列长度
- 给定入队序列,一个出对序列(完全相同)(先进先出)
- typedef int ELe;
- int front,rear;
- 顺序队列/链式队列

# 顺序队列
- 一维数组A(0到n-1),m个元素
- A[0]对头,A[m-1]队尾
- 出队时,队头A[0]删除,后面m-1个元素前移1
- O(m)
# 存储结构
- 交换队头队尾
- 入队时,m个元素均需后移1,腾出A[0]放新元素
- O(m)
- front(队头),rear(队尾)
- 入队新元素放最后面
- 最后入队(越界),前段出队空闲
- 重复利用前空闲存后入队
# 例
设队列保存容量7数组A,
依次将5,12,9,37入队列
将5,12出队列,将25,8入队列,
将16入队列,将9出队列,将7,4入队列

# 循环队列
- 顺序队列都实现为循环队列
- 入队,rear=(rear+1)%n
- 出队,front=(front+1)%n
- 数组首尾相接
# 空与满
- 队满,rear==front
- 条件rear==front也代表空队列
- 解决:始终空一位置,队满
- 初始front=0且rear=0
# 清空队列
- 队头队尾赋值0(初始化/空队列)
- 队头和队尾相等(空队列)
# 判空/满
- 空,rear==front
- 满,(rear+1)%n=front

# 链式队列
- 单链表(头指针和尾指针)
- 头指针/队头,尾指针/队尾
# 判空
- 队头和队尾指针相等
- 空链式队列(头尾都NULL)
- 内存够大(链式不会满)
# 带空闲单元链表的链式队列
- 空闲链表(少malloc/free函数)
- 循环链表(实际节点/空闲节点)
```

```shell
# 双端队列
- 输入受限
- 输出受限
# 栈与队列的相互模拟
- 使用双栈来模拟队列
```

```shell
### 栈和队列的应用: 
# 1.括号的匹配检查
- 符号成对(次序正确/嵌套不交错)
- 左开右闭
- 符号匹配正确(平衡表达式)
- 栈(校验符号平衡)
# 栈存储及实现
- 左右扫描(忽略非括号)
- 开括号(保存)
- 闭括号(对应最近开括号)
- 是(丢开括号)
- 扫描完(都匹配)
- 栈(保存开括号)
# 不平衡情况
- 闭括号与栈顶开括号不匹配(有交错)
- 扫描尾/栈不空(开多于闭)
- 扫描到闭括号栈空(缺少开括号)

# 2.表达式计算
# 表示形式及计算次序
- 中缀表达式: <操作数><运算符><操作数> c*(a+b)
- 前缀表达式: <运算符><操作数><操作数>
- 后缀表达式: <操作数><操作数><运算符>
# 中缀转后缀
- 每个运算符(加括号/右移-紧贴闭)
- 去掉括号(后缀表达式)
- 左右扫描中缀,遇数直接输出
遇运算符,保存栈(满足条件输出栈顶运算符)
- 读到运算符(比较栈内运算符)
栈内优先高栈外(输出栈内)
栈外高栈内(栈外入栈)
- 读到尾,出栈全部运算符

# 3.后缀表达式计算
# 从左至右扫描后缀表达式
- 遇到操作数,进栈
- 遇到运算符,从栈中弹出两个操作数,
并进行运算,结果放到栈
- 先弹出/右操作数,后弹出/左操作数

# 打印杨辉三角形
- 前一行数据(1)
- 规律生成后一行数据
```



## 数组广义表和串

## 树与二叉树

## 图结构

## 内部排序

## 查找


## 算法设计策略

```shell
# 一、递推法
- 直接求解
- 递推关系(问题规模部分)
```

```shell
# 二、迭代法
- 直接求解
- 迭代关系式(前值/后值)
- 迭代次数/迭代条件
```

```shell
# 三、递归法
```

```shell
# 四、贪心法
```

```shell
# 五、分治法
```

```shell
# 六、动态规划法
```

## 线性表

```shell
### 线性表定义
- 同类型数据元素
- 有限序列
- (表项-表长-表头-表尾-前驱-后驱-空表)
# 线性表基本操作
- 查(索引/长度/元素)
- 增删改(索引/元素)
# 存储结构
- 顺序存储结构(数组/顺序表)
- 链表存储结构(链表)
```

```shell
### 顺序表
- 连续的存储单元(依次存储)
- 逻辑相邻(存储地址相邻)
- (下标/首地址/存储地址)
# 插入删除
- 插入(移动元素平均次数为n/2)
- 删除(移动元素平均次数(n-1)/2)
- 逆置(头尾交换->中间)
```

```shell
### 链表
- 结点(各元素/各存储空间)
- 指针域/数据域
- 循环
# 单链表
- 动态分配节点
- 元素和指针(指向后驱)
- 头节点(空表标志/表长)
# 插入删除
- 创建节点
- 节点指针(前后)
# 双向链表
# 插入删除
- 创建节点
- 节点指针(后前)
```

```shell
### 两种方式对比
- 顺序表元素空间(紧凑/连续)
- 数组每单元(数据/没有额外)
- 链表(数据/指针结构性开销/单双)
- 数组宽松(空闲空间)
- 链表空间元素个数正比(全部)
- 元素少(链表更节省)
- 元素大(数组存储效率高)
- 结构性开销(双单2倍)
# 如何选择
- 个数变化大或未知,链表
- 知道大致长度,顺序表
- 连续/零散,需要分配释放
- 操作时间复杂度
# 复杂度差异
- 顺序表直接定位(随机访问),O(1)
- 单链表不能随机访问,平均和最差均为O(n)
- 给出指针,插入删除可O(1)
- 顺序表插入删除,平均和最差均为O(n)
# 例1
设n元素个数,D最多个数,P指针大小,E数据大小
顺序表:D*E
单链表:n*(P+E)
n临界值:n=D*E/(P+E)
双是单2倍
# 例2
设L每个元素空间10字节,指针2字节
用单链表或含30元素数组保存L
哪种空间存储率更高?仅考虑L元素
- 单链表节点12字节
- 数组空间30*10=300,单链表300/12=25
- 不考虑表头节点,少于25,单链表
- 多于25,数组
- 等于25,一样大
```

```shell
# 空闲单链表
- 插入删除malloc/delete,开销可观
- 伙伴链表,结构一致(管理暂时不用的节点)
- 删除节点,插入freelist
- 申请节点,从freelist获取,保存插入,否则malloc
# 静态链表特点
- 保存在数组中
- 兼具顺序表链表特性,空间不零碎,
插入删除不需要移动元素
# 静态链表操作
- 插入删除(直接)
```

```shell
### 单链表应用
# 查找单链表倒数第k个节点
- n-k+1, front/rear
- 初始front前进k步
- 然后同步前进
- front表尾,rear为倒数k
```

## 栈和队列

## 数组广义表和串

## 树与二叉树

## 图结构

## 内部排序

## 查找


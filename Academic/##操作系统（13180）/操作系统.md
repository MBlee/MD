## 一、操作系统概论

#### 计算机系统

```shell
# 1.定义
计算机系统是一种可以按用户的要求接收和存储信息、
自动进行数据处理并输出结果信息的系统。
# 2.分类:
>广义:机械式系统和电子式系统
>电子式系统:模拟式和数字式计算机系统
# 3.组成
>硬件(子)系统和软件(子)系统
```

```shell
# 软件系统(程序、数据)
应用软件:文字处理、图形图像处理、科学计算、MIS...
支撑软件:数据库、网络、多媒体...
系统软件:操作系统、编译程序...
# 硬件系统
中央处理器(CPU)、内存储器
外存储器(磁盘、磁带)输入输出设备(键盘、鼠标、显示器、打印机...)
```

```shell
# 计算机系统的资源:硬件资源、软件资源
在计算机系统中，
集中了资源管理功能和控制程序执行功能的一种软件，
称为操作系统。
```

#### 操作系统

```shell
# 定义
操作系统是计算机系统中的一个系统软件，
它是这样一些程序模块的集合:
它们能有效地组织和管理计算机系统中的硬件及软件资源，
合理地组织计算机工作流程，
控制程序的执行，并向用户提供各种服务功能，
使得用户能够灵活、方便、有效地使用计算机，
并使整个计算机系统能高效地运行。
# 定义解析:
# 1.组织和管理计算机系统中的硬件资源和软件资源。
在操作系统中，设计了各种表格或数据结构，
将所有的软硬件资源都加以登记。
比如:PCB、系统设备表等。
# 2."有效”
指操作系统在管理计算机资源时
要考虑到系统运行的效率和利源的利用率。
要尽可能提高中央处理器的利用率，
让它尽可能少的空转，
应该在保证访问效能的前提下尽可能有效地利用其它资源。
比如:减少内存、硬盘空间的浪费等
# 3."合理”
指操作系统要“公平”对待不同的用户程序，
保证系统不发生“死锁”和“饥饿”的现象。
# 4."方便”
指操作系统的人机界面要考虑到
用户使用界面和程序接口两个方面的易用性、易学性和易维护性。
用户使用接口:命令、图形界面，如Window图形界面。
程序接口:程序员能够使用操作系统提供的服务供程编程。
如Window提供的API接口，Linux的系统调用。
```

#### 操作系统特征

```shell
# 1.并发性:
是指在计算机系统中同时存在着若干个运行着的程序，
从宏观上看，这些程序在同时向前推进。
# 2.共享性:
操作系统需与多个用户程序共用系统中的各种资源，
比如CPU、内存、外部设备等。
# 3.随机性
操作系统不能对所运行的程序的行为
以及硬件设备的情况作出任何事先的假定。
即操作系统不能预知程序在什么时候运行，
什么时候因为什么原因暂停，
什么时候能得到资源继续运行，
什么时候运行结束等，这些都是不可预知的。
```

#### 研究操作系统的观点

```shell
# 1.软件的观点:
操作系统是一种大型系统软件，
它是多种功能程序的集合。
有外在特性和内在特性。
外在特性:接口
内在特性:与硬件交互
# 2.资源管理的观点
操作系统负责登记谁在使用什么样的资源，
系统中还有哪些资源空闲，
当前响应了谁对资源的请求，
以及回收那些不再使用的资源等。
# 3.进程的观点
把操作系统看做由多个可以同时独立运行的程序
和一个对这些程序进行协调的核心。
侧重于分析系统各部分的并行工作，
研究处理各项管理任务的分割以及这些管理任务相互之间的关系，
比如:竞争资源、进程通信等。
# 4.虚机器的观点
在操作系统的支持下，
用户不需要直接使用硬件机器(裸机)，
而是通过操作系统提供的各种手段来控制和使用计算机。
例如，把所有对设备和文件的操作抽象为统一的打开、关闭、读、写等，
用户感觉不到底层的操作差异。
把操作系统的全部功能，
包括系统调用、命令、作业控制语言等，
称为操作系统虚机器。
# 5.服务提供者观点
从用户的角度，
站在操作系统之外观察操作系统，
认为该服务提供者为用户提供了比裸机功能更强、
服务质量更高、更方便灵活的虚拟机。
```

#### 操作系统的功能

```shell
进程管理
存储管理
文件管理
设备管理
用户接口
```

```shell
1.进程管理
进程管理的实质:对中央处理器进行管理。或者称为处理机管理。
多道程序技术:多个程序同时放入内存，如果一个程序因为等待某个条件而不能运行，就把处理器专用权转交给另一个可运行程序。
进程的引入:为了描述多道程序的并发而引入
进程的简单定义:一个程序的运行过程
进程管理的内容:进程控制、进程同步、进程间通
信、调度。
2.存储管理
(1)任务:管理计算机内存的资源
(2)功能:
1内存的分配与回收:当多个程序共享有限的内存资源时，要考虑如何为多个程序分配有限的内存空间，以及程序运行完毕还需要内存回收。
2存储保护:存储在内存中的多个程序和数据应该彼此隔离、互不侵扰。
3内存扩充:将辅助存储器作为内存的扩充空间。
3.文件管理
(1)任务:
有效地支持文件的存储、检索和修改等操作，解决文件的共享、保密和保护问题，以便用户方便、安全地访问文件。
(2)功能:
1文件存储空间的管理
2目录管理
3文件系统的安全性
4.设备管理
(1)设备管理的含义:
指计算机系统中除了处理器和内存以外的所有输入、输出设备的管理。
(2)功能:
负责外部设备的分配、启动和故障处理。
(3)采用的技术
中断技术、通道技术、虚拟设备技术、缓冲技术，尽可能发挥设备和主机的并行能力。
5.用户接口
从用户观点看，操作系统是用户与计算机之间的接口。任务:为用户提供一个使用系统的良好环境，使用户能有效地组织自己的工作流程，并使整个系统高效地运行。
```

#### 操作系统的体系结构

#### Windows操作系统的体系结构

```shell
1.内核
功能:线程调度、陷入处理和异常调度、中断处理和调度、多处理器同步、供执行体使用的基本内核对象。
2.硬件抽象层HAL
系统可移植性的关键部分，为运行在Windows操作系统上的硬件平台低级接口，隐藏了各种与硬件有关的细节，如I/O接口等专用的和依赖于计算机平台的函数。
3.执行体
属于内核，以系统函数的形式提供了系统的服务，可通过Win32API进行访问
4.系统进程和系统线程
执行系统代码
```

#### UNIX操作系统的体系结构

```shell
1.内核层
是操作系统管理和控制中心，常驻内存。有两种接口:内核与硬件的接口和内核与shell的接口。内核本身分为两部分:进程控制子系统和文件子
系统。
2.系统层
内核层与应用层之间，供程序员开发调用，包括进程管理、文件管理、中断状态。
3.应用层
面向用户操作的界面

UNIX命令和库
系统调用接口
内核
硬件
用户应用程序
```

#### Linux操作系统的体系结构

```shell
四个部分:
系统和应用程序
内核、shell、文件

从低到高:应用程序层、应用框架层、系统运行库层和Linux内核层。
```

#### 操作系统的发展

```shell
1.手工阶段
2.监控程序
3.多道批处理
4.分时与实时操作系统
5.UNIX通用操作系统
6.个人计算机操作系统
7.Android操作系统
```

#### 操作系统的分类

```shell
# 根据用户界面和功能特征分类
三种基本类型:
1.批处理系统
2.分时系统
3.实时系统
# 随着体系结构的发展
新类型:
1.个人操作系统
2.网络操作系统
3.分布式操作系统
4.嵌入式操作系统
```

```shell
# 一、批处理操作系统
1.基本工作方式
用户将作业交给系统操作员，系统操作员在收到作业后，并不立即将作业输入计算机，而是收到一定数量的用户作业之后，组成一批作业，再把这批作业输入到计算机中。这批作业可在系统中形成一个连续的、自动转接的作业流。系统操作员然后启动操作系统，系统自动、依次执行每个作业。
最后由操作员将执行完毕的作业交给用户。
2.特点与分类
特点:成批处理，用户不能干预自己作业的运行目标:系统资源利用率高，作业吞吐率高。分类:简单批处理和多道批处理
3.设计思想:在监控程序启动之前，操作员有选择地把若干个作业合并成一批作业，将这批作业安装在输入设备上。然后启动监控程序，监控程序将自动控制这批作业的执行。作业的运行与衔接都由监控程序自动控制，从而有效地提高了作业运行的效率。
4.作业控制说明书
作业控制说明书是由作业控制语言编写的一段程序，它通常存储在被处理作业的前面。
作业的运行由作业控制说明书来传递给监控程序，运行过程中，监控程序读入并解释作业说明书，以控制各个作业步的执行。
5.一般指令和特权指令
操作系统的运行模式:用户模式和特权模式处理器的状态:目态和管态机器指令:一般指令和特权指令系统调用:用户程序不能直接使用特权指令，它们必须向操作系统请求这些功能，这些功能通过系统调用完成。
6.系统调用的过程
首先，当系统调用发生时，由中断或异常处理程序，把控制流程转移到监控程序内的一些特定位置，处理器模式变为特权模式。
其次，由监控程序执行被请求的功能。最后，恢复现场，运行模式转变为用户模式，控制权交给用户程序。
7.SPOOLing技术
是多道程序设计的关键技术之一，也称为假脱机技术。

```

```shell
# 二、分时系统
1.基本工作方式
在分时系统中，一台主机连接了若干个终端，每个终端可由一个用户使用。用户通过终端交互式地向系统提出命令请求，系统接收用户命令之后，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。
2.特点:
多路性
交互性
“独占性”
及时性
```

```shell
# 三、实时操作系统
实时操作系统是指，使计算机能在规定的时间内及时响应外部事件的请求，同时完成对该事件的处理，并能够控制所有实时设备和实时任务协调一致地工作的操作系统。
目标:在严格时间范围内，对外部请求做出反应，系统具有高可靠性。
分类:
硬实时系统和软实时系统
能力:
除了多道程序系统的基本能力外，还有以下功能:
(1)实时时钟管理
(2)过载防护
(3)高可靠性
```

```shell
# 四、嵌入式操作系统
1.定义
在各种电器、电子和智能机械上，嵌入安装着各种微处理器或微控制芯片。
嵌入式操作系统就是运行在嵌入式芯片环境中，对整个芯片以及它所操作、控制的各种部件装置等资源进行统一协调、调度、指挥和控制的系统软件。
```

```shell
# 五、其他操作系统
1.个人计算机操作系统
2.网络操作系统
3.分布式操作系统
```

#### 操作系统设计

```shell
# 一、操作系统的设计过程
1.功能设计
确定所设计的操作系统应具备哪些功能以及操作系统的类型。跟目标有关。
2.算法设计
选择和设计满足系统功能的算法和策略，并分析和估算其效能。
3.结构设计
```

```shell
# 二、操作系统的设计目标
1.可靠性
2.高效性
3.易维护性
4.可移植性
5.安全性
6.简明性
```

```shell
# 三、操作系统的结构设计
操作系统结构研究的目标
1.系统模块化
2.模块标准化
3.通信规范化
```

```shell
# 四、操作系统的结构
常见的操作系统结构
1.整体式结构
2.层次式结构
3.微内核(客户/服务器)结构
```

## 二、操作系统运行环境

#### 处理器

```shell
# 一、处理器的构成与基本工作方式
处理器一般由运算器、控制器和一系列寄存器以
及高速缓存构成。
运算器实现算数与逻辑运算。
控制器控制程序运行流程。
寄存器用于处理器执行指令的过程中暂存数据、地址及指令信息。
高速缓存:为CPU和内存提供一个高速的数据缓存区域。
1.处理器中的寄存器
两类寄存器:
(1)用户可见寄存器，由编译程序分配，减少程序运行时访问内存的次数。一般包括数据寄存器，地址寄存器、条件码寄存器。
(2)控制和状态寄存器，用来控制处理器的操作常见的寄存器是程序计数器(PC)、指令寄存器(IR)、程序状态字(PSW)。
2.指令执行的基本过程
最简单的是两个步骤:
(1)读取指令，并将程序计数器的值变成下一条指令的地址。
(2)指令放入指令寄存器中，处理器解释并执行
该指令。
指令的分类:
访问存储器指令、V/O指令、算数逻辑指令、控制转移指令、控制器控制指令。
```

```shell
# 二、特权指令和非特权指令
在多道程序环境下，指令分为特权指令和非特权指令。1.特权指令:
>在操作系统中那些只能由操作系统使用的指令。
>不允许一般用户使用。
比如:设置程序状态字、启动某设备、设置中断屏蔽字等。
2.非特权指令:
普通用户使用的指令
```

```shell
# 三、处理器的工作状态
2.处理器工作状态的转换
目态到管态的转换:唯一途径是通过中断。中断响应时交换中断向量，新的中断向量的PSW的处理器状态标志位管态。
管态到目态的转换:可通过设置PSW指令，实现从操作系统到用户程序的转换。

1.管态和目态
管态:操作系统管理程序运行时的状态，又称内核态、系统态等，具有较高特权。
目态:一般用户程序运行时的状态，又称用户态、普通态，具有较低特权。
3.限制用户程序执行特权指令
当用户程序执行时，如果取到了一条特权指令，则处理器拒绝执行该指令，并形成一个"非法操作”事件。然后操作系统通知用户程序--程序中有非法指令。
```

```shell
# 四、程序状态字
为了解决处理器当前工作状态的问题，所有的处理器都有一些特殊寄存器，用以表明处理器当前的工作状态。用来指示处理器状态的寄存器，称为程序状态字。比如CF:进位标志、ZF:结果为零标志等。

程序状态字一般包括:
CPU的工作状态代码:指明当前的工作状态是管态还是目态。
条件码:反映指令执行后的结果特征，比如结果
为0等。
>中断屏蔽码:指出是否允许中断
```

#### 计算机系统硬件部件

```shell
# 一、存储系统
1.存储器的类型
(1)类型
读写型存储器(RAM)，用来存储随机存取的程序和数据
只读存储器(ROM)，存放一些固化的程序
(2)存储分块
存储的最小单位:位(bit)最小编制单位:字节分块:为了分配和管理方便，将内存划分为大小相等的块(物理页Page)，以块为单位分配内存空间，大小一般为512B，1KB、4KB、8KB等
2.存储器的层次结构
(1)容量、速度和成本的匹配
寄存器
高速缓存
内存储器
磁盘存储器
远程存储(云存储)
计算机系统中的存储设置
(2)存储访问局部性原理
程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下是顺序执行的。过程调用将会使程序的执行轨迹，由一部分区域转至另一部分区域。即程序将会在一段时间内，都局限在这些过程的范围内运行。
程序中存在许多循环结构，这些虽然只由少数指令构成，但是它们将多次执行。
程序中还包括许多对数据结构的处理，如对数组进行操作，它们往往都局限于很小的范围内。基于这一原理，设计多级存储的体系结构
3.存储器保护
多道程序设计系统中，保证每个程序独立运行、互不干扰，称为存储器保护。
方法:界地址寄存器
```

```shell
# 二、1/0部件
1.I/O结构
2.通道
3.DMA技术
4.缓冲技术
```

```shell
# 三、时钟部件
功能:
(1)发现死循环，防止机时的浪费
(2)分时系统中，时钟间隔实现时间片轮转执行(3)实时系统中，按要求的时间间隔控制设备
(4)定时唤醒各个外部事件
(5)记录各种设备的使用时间和某外部事件发生的时间间隔(6)记录用户和系统所需的绝对时间，即年、月、日
分类:
硬件时钟和软件时钟用途分:绝对时钟和相对时钟
```

#### 中断机制

```shell
# 一、中断与异常的概念
1.中断与异常
中断:指处理器对系统中或系统外发生的异步事件的响应。
异步事件:指无一定时序关系的随机发生的事件，如外部设备完成了数据传输任务，某一实时控制设备出现异常情况等。
中断源:引起中断的事件称为中断事件或中断源。
中断请求:中断源向处理器发出的请求信号。
中断处理程序:处理中断事件的程序
断点:发生中断时正在执行的程序的暂停点。
中断响应:处理器暂停当前程序转而处理中断的过程。
中断返回:中断处理程序结束后恢复原来程序的执行。
中断向量表:为了使得中断装置可以找到恰当的中断处理程序，专门设计了中断处理程序的入口地址映射表，又称中断向量表。
异常:由正在执行的指令引发的中断。
2.中断与异常的分类
典型的中断:时钟中断、输入输出中断、控制台中断、硬件故障中断。
典型的异常:程序性中断，访管指令异常。
```

```shell
# 二、中断系统
1.中断请求的接收
中断系统如何接受中断源的中断请求，因机器而异。
般由中断逻辑线路和中断寄存器实现。
2.中断响应
处理器的控制部件中有中断信号扫描结构，它在每条指令执行周期内的最后时刻扫描中断寄存器，查看是否有中断信号到来。若无中断信号，处理器就继续执行下一条指令。若有中断到来，处理器接收由硬件中断装置发来的中断向量代号，准备中断处理准备工作

中断请求响应过程:
处理器接收中断信号;
保护现场
分析中断向量
将处理器的PC值置为中断程序的入口地址
调用中断处理程序。
3.中断处理
中断信号被接收和响应之后，进行中断处理，包括:检查I/O相关的状态信息，操纵I/O设备或者在设备和内存之间传送数据等。
中断处理结束后，中断返回，恢复系统上下文，原有程序继续运行。处理器状态也从管态恢复成目态。
整个中断信号的接收、响应和处理过程，可归纳
为以下步骤:
(1)接收和响应中断
(2)保护中断断点现场
(3)分析中断向量，调用中断处理程序(4)中断处理结束恢复现场，原有程序继续执行
4.几种典型中断的处理
(1)1/O中断(2)时钟中断(3)硬件故障中断(4)程序性中断(5)系统服务请求
```

```shell
# 三、中断优先级、中断屏蔽与中断嵌套
1.多级中断与中断优先级
作用:
(1)对各类中断信号依据其紧急程度和重要性划分级别，系统优先处理最紧急或最重要的任务。
(2)解决如果有多个中断信号同时到达，如何选择首个被处理的中断信号的问题。
2.中断屏蔽
整个中断系统中，允许或者禁止中断系统对某些类别中断的响应。PSW中设计有中断屏蔽位。
比如:某个I/O被中断屏蔽，意味着即使有I/O中断信号处理器也不予响应。
注意:有些信号是不能被屏蔽的，一般这类中断信号于机器故障中断，比如掉电，机器无法继续操作。一旦发生无论信号是否被屏蔽，处理器都会立即响应，并进行处理。
3.中断嵌套
一般的计算机系统都有多个中断源，如果一个中断处理的过程中又发生了中断，有两种策略处理:
(1)当处理一个中断时禁止其他中断
(2)中断嵌套。即中断按照优先级划分，允许优先级高的中断优先级低的中断处理过程，优先进行处理。如图2-6所示。
```

#### 系统调用

```shell
# 一、系统调用简介
系统调用概念:
就是用户在程序中调用操作系统提供的一些子功能，是操作系统提供给编程人员的唯一接口。
是一种特殊的过程调用，由特殊的机器指令实现，这条指令将系统转入管态。
1.系统调用与函数调用的区别
(1)运行在不同状态
(2)状态的转换
(3)返回问题
(4)嵌套调用
2.系统调用的分类
(1)进程控制类
(2)文件操作类
(3)进程通信类
(4)设备管理类
(5)信息维护类
3.系统调用与库函数、API、内核函数的关系
应用程序
C库函数/API
系统调用
内核
```

```shell
# 二、系统调用的处理过程
陷入(trap):
在系统中为控制系统调用服务的机构称为陷入或异常处理机构。
陷入或异常指令(访管指令):
把由于系统调用引起处理器中断的指令称为陷入或异常指令(或称访管指令)。
处理过程:
图2-8
用户程序
系统调用
陷入处理机制
(1)保护处理器现场
(2)根据系统调用号查找系统调用子程序的入口地址
(3)返回
入口地址表
系统调用子程序
```

## 三、进程与线程

#### 多道程序设计

```shell
# 一、程序的顺序执行
# 1.顺序程序设计:
程序是在一个时间上按严格次序前后相继的操作序列。
计算机也是以顺序方式工作的:
计算机一次执行一条指令、
对内存一次访问一个字节或字，
对外部设备一次传送一个数据块等。
我们把一个具有独立功能的程序独占处理器
直到得到最终结果的过程称为程序的顺序执行。
# 2.程序的顺序执行的特点:
(1)顺序性
程序所规定的动作在机器上严格地按顺序执行。
(2)封闭性
程序运行后，其计算结果只取决于程序自身，
程序执行得到的最终结果由给定的初始条件决定，
不受外界因素影响。
(3)程序执行结果的确定性
程序执行的结果与其执行速度无关。
(4)程序执行结果的可再现性
如果程序在不同的时间执行，
只要初始条件相同则结果就会相同。
```

```shell
# 二、程序的并发执行
所谓并发执行，
是指两个或两个以上程序在计算机系统中，
同时处于已开始执行且尚未结束的状态。
能够参与并发执行的程序称为并发程序。
并发程序的执行和程序顺序执行的特征不同。
# 并发执行的特征如下:
(1)在执行期间并发程序相互制约
(2)程序与计算不再一一对应
允许多个程序共享一个程序段
(3)并发程序的执行结果不可再现
并发程序与其执行的相对速度以及
并发执行的多道程序之间的相互关系有关。
(4)程序的并行执行和程序的并发执行
程序的并发执行是宏观上的同时，微观是顺序。
并行则是微观上是同时的。
```

```shell
# 三、多道程序设计
a)顺序环境下
CPU的利用率=40/80=50%
DEV1的利用率=15/80=18.75%
DEV2的利用率=25/80=31.25%
b)并发环境下
CPU的利用率=40/45=89%
DEV1的利用率=15/45=33%
DEV2的利用率=25/45=56%
# 1.多道程序设计技术的引入
# 2.多道程序设计环境特点
多道程序设计:就是允许多个程序同时进入内存并运行。
根本目的是提高整个系统的效率。
吞吐量:是指单位时间内系统所处理进程的道数，
是衡量系统效率的尺度。
(1)独立性
在多道环境下执行的每道程序都是逻辑上独立的，
且执行速度与其他程序无关，
执行的起止时间也是独立的。
(2)随机性
程序和数据的输入与执行开始时间都是随机的
(3)资源共享性
# 3.多道程序设计环境缺陷
(1)可能延长程序的执行时间
(2)系统效率的提高有一定限度
```

#### 进程

```shell
# 一、进程的定义
进程是具有一定独立功能的程序
在某个数据集合上的一次运行活动，
是系统进行资源分配和调度的一个独立单位。
分为:系统进程和用户进程
# 1.进程与程序的联系和区别
(1)进程和程序的联系
程序是构成进程的组成部分之一，
一个进程的运行目标是执行它所对应的程序。
进程=程序+数据+进程控制块
(2)进程和程序的区别
程序是静态的，进程是动态的。
二者是多对多的关系。
# 2.可再入程序
一个能够被多个用户同时调用的程序
称作是“可再入”程序。
可再入程序必须是纯代码，
程序在执行过程中不会修改自己的代码，
必须与数据区隔离。
比如:操作系统、编译程序，
它们能同时被不同用户调用而形成不同的进程。
# 3.进程的特征
(1)并发性
(2)动态性
(3)独立性
(4)交往性
(5)异步性
(6)结构性
```

```shell
# 二、进程的状态与转换
# 1.三状态进程模型
(1)运行状态
(2)就绪状态
(3)等待状态
状态转换
(1)就绪-》运行（时间片完成）
(2)运行-》就绪（进程调度）
(3)运行-》等待（I/O请求）
(4)等待-》就绪（I/O完成）
# 2.五状态进程模型
(1)运行状态（调度）
(2)就绪状态（超时、被抢占）
(3)阻塞状态（等待时间发生）
(4)创建状态（提交）
(5)结束状态（释放）
# 3.七状态进程模型

```

```shell
# 三、进程控制块
为了便于系统控制和描述进程的活动过程，
在操作系统核心中定义了一个专门的数据结构，
称为PCB。
# PCB的作用:
描述进程的基本情况以及进程的运行变化过程。
PCB是进程存在的唯一标志，
当系统创建一个进程时，
为进程设置一个PCB，
再利用PCB对进程进行控制和管理。
撤销进程时，系统收回PCB，
进程也随之消亡。
# 1.PCB的内容
(1)调度信息
供进程调度时使用，
包括进程名、进程号、
地址空间信息、优先级、
当前状态、资源清单、
“家族”关系、消息队列指针、
进程队列指针和当前打开文件等。
(2)现场信息
刻画了进程的运行情况，
主要是CPU寄存器的信息，
如程序状态字、时钟、界地址寄存器等。
当程序中断时，需要保存现场信息。
# 2.进程的组成
进程由程序、数据和进程控制块组成
PCB是“灵魂”;
程序和数据是“躯体”
# 3.PCB组织
线性方式
索引方式
链接方式
# 4.进程的队列
就绪队列
等待队列
运行队列
# 5.进程队列的组成
进程队列实际是PCB的链接，
链接分为:单向链表和双向链表。
出队:一个进程从所在队列退出
入队:一个进程排入到指定队列
插队:一个进程插入到某个进程队列的指定位置。
```

```shell
# 四、进程控制
进程控制:
对进程整个生命周期中各种状态之间的转换进行的控制。
由原语实现。
原语:
就是由若干条指令组成的，
用于完成一定功能的一个过程，
是一个不可分割的基本单位，
即原语在执行过程中不允许被中断。
原子操作在系统态下执行，常驻内存。
# 1.进程控制原语
(1)创建原语
(2)撤销原语
(3)阻塞原语
(4)唤醒原语

(1)创建原语
一个进程可以使用创建原语创建一个新的进程，
前者称为父进程，后者称为子进程，
子进程又可以创建新的进程，
从而形成一个进程家族。
主要任务:建立进程控制块PCB。
过程:先申请一空闲PCB，然后将有关信息填入PCB，
置进程状态为就绪状态，插入就绪队列。

(2)撤销原语
当一个进程完成任务后，
就应当撤销它，
以便及时释放它所占用的资源。
撤销的实质:撤销进程控制块PCB。
过程:找到要被撤销进程的PCB，
将它从所在队列中消去，
撤销属于该进程的一切“子进程”，
释放所占全部资源，
并消去被撤销进程的PCB。

(3)阻塞原语
若某个进程的执行过程中需要I/O操作，
则该进程调用阻塞原语将其从运行状态转换为阻塞状态。
过程:产生中断，把处理器的当前状态保存在PCB的现场信息中，
当前进程置为等待态，插入等待队列。

(4)唤醒原语
一个进程因为等待某事件的发生而处于等待状态，
当该事件发生后，就用唤醒原语将其转换为就绪状态。
过程:在等待队列中找到该进程，
将进程的当前状态置为就绪状态，
然后将它从等待队列中撤出并插入到就绪队列中排队，
等待调度执行。
```

#### 线程

```shell
# 进程的属性:
- 一个可拥有资源的独立单位
- 可独立调度和分派的基本单位
程序并发执行所需付出的时空开销:
创建进程的开销
- 内存空间、I/O设备、PCB
撤销进程的开销
- 对其资源作回收
进程切换的开销
- 保留CPU环境，设置新进程CPU环境
这些开销，限制了系统中进程的数目，
进程切换也不宜频繁，
限制了并发程度的进一步提高
# 引入线程的目的
引入进程是为了使多个进程并发执行。
引入线程是为了减少程序并发执行时所付出的时空开销。
# 1.什么是线程
在引入线程的操作系统中，
线程是进程中的一个实体，
是处理器调度和分配的基本单位。
线程基本上不拥有系统资源，
只拥有少量在运行中必不可少的资源，
但它可与同属一个进程的其他线程
共享进程所拥有的全部资源。
一个线程可以创建和撤销另一个线程;
同一个进程中的多个线程可以并发执行。
# 2.线程的属性
(1)每个线程有一个唯一的标识和一张线程描述表。
(2)不同的线程可以执行相同的程序
(3)同一个进程中的各个线程共享该进程的内存地址空间
(4)线程是处理器的独立调度单位，多个线程可以并发执行
(5)一个线程具有生命周期，经历等待、就绪、运行等状态变化。
# 3.引入线程的好处
(1)创建一个新线程花费时间少。
(2)线程之间的切换花费时间少
(3)线程之间通信无需调用内核，
不需要额外的通信机制，
使通信简单、信息传送速度快。

```

```shell
# 二、进程和线程的比较
1.调度
2.并发性
3.拥有资源
4.系统开销
# 1.调度
线程作为调度的基本单位，
同进程中线程切换不引起进程切换，
当不同进程的线程切换时才引起进程切换。
# 2.并发性
一个进程间的多个线程可并发,
不同进程的多个线程也可以并发执行。
# 3.拥有资源
线程仅拥有隶属进程的资源;
进程是拥有资源的独立单位。
# 4.系统开销
线程低，进程高。
```

```shell
# 三、线程实现机制
# 1.用户级线程
仅存在于用户空间，
由用户层中的线程库提供对线程的创建、撤销、切换，
以及线程之间的同步与通信等的支持，
而无须内核的支持。
2.内核级线程
由OS直接支持，更灵活，方便。
3.混合方式

```

#### 进程调度

```shell
# 1.进程调度的主要功能
(1)记录系统中所有进程的执行状况;
(2)根据一定的调度算法，
从就绪队列中选出一个进程，
准备把处理器分配给它;
(3)分配处理器
# 2.进程调度的时机
(1)正在执行的进程运行完毕
(2)正在执行的进程由于某种错误而终止运行
(3)时间片完
(4)正在执行的进程调用阻塞原语将自己阻塞起来
(5)创建了新的进程
(6)正在执行的进程调用了唤醒原语操作激活了等待资源的进程。

```

```shell
# 处理器的调度方式非抢占式和抢占式
(1)非抢占方式
一旦把处理机分配给某进程后，
就一直让它运行下去，
决不会因为时钟中断，或任何其它原因，
去抢占该正在运行进程的处理机，
直至该进程完成，
或发生某事件而被阻塞时，
才把处理机分配给其它进程。
(2)抢占方式
允许调度程序根据某种原则，
去暂停某个正在执行的进程，
将已分配给该进程的处理机，
重新分配给另一进程。
抢占方式能满足实时任务的需求。
但抢占方式比较复杂，
所需付出统开销也较大。
```

```shell
# 二、调度算法设计原则
# 1.进程行为
I/O密集型和计算密集型
# 2.系统分类
批处理、交互式、实时系统
# 3.调度算法的设计目标
共同目标:资源利用率高、公平、平衡、强制执行策略。
批处理目标:平均周转时间短、系统吞吐量高、处理机利用率好
分时系统目标:响应时间快、均衡性
实时系统目标:截止时间的保证、可预测性
```

```shell
# 三、进程调度算法
1.先来先服务
2.最短进程优先
3.最短剩余时间优先算法
4.最高响应比优先算法
5.轮转算法
6.最高优先级算法
7.多级反馈队列算法
# 1.先来先服务
(1)算法思想:总是把处理机分配给最先进入就绪队列的进程，
一个进程一旦分得处理机，便执行下去，
直到该进程完成或阻塞时，才释放处理机。
(2)优点:实现简单。
(3)缺点:没考虑进程的优先级。
# 2.最短进程优先算法
(1)算法思想:
该算法从就绪队列中选出“下一个CPU执行期”最短的进程，
为之分配处理机。
(2)优点:
所有进程都同时可运行时算法最优。
# 3.最短剩余时间优先算法算法思想
总是选择剩余时间最短的那个进程运行。
当一个新的进程到达时，
其整个时间同当前进程的剩余时间做比较，
如果新进程时间更少，
则当前进程被挂起，运行新进程。
# 4.最高响应比优先算法
(1)算法思想:总是优先调度响应比最大的进程
(2)性能:先来先服务和最短进程优先算法的折中
# 5.轮转算法
(1)算法思想:
最早来自于分时系统。
将处理器的处理时间划分成一个个时间片，
就绪队列中的诸进程轮流运行一个时间片，
当时间片结束时，就强迫运行进程让出处理器，
该进程进入就绪队列，
等待下一次调度。
(2)影响时间片设置的因素:
-系统响应时间
-就绪进程数目
-计算机的处理能力
小结:时间片设得太短，
导致过多的进程切换;
太长，响应时间变长。
合理的时间片20~50ms
# 6.最高优先级算法
(1)算法思想:
为每个进程设立一个优先级，
每次将处理器分配给具有最高优先级的就绪进程。
(2)可以保证紧迫性进程优先运行
# 7.多级反馈队列算法
结合了先进先出、时间片轮转、可抢占式最高优先级调度算法。
(1)算法思想要点:
被调度队列的设置
在同一个队列内的调度原则
在不同调度队列之间的调度原则
进程优先级的调整原则
```

#### 系统内核

```shell
# 二、内核的位置
内核本身不是进程，
是系统进程和用户进程赖以活动的基础，
一般内核常驻内存，
操作系统其它部分则根据需要调进或调出内存。
```

```shell
# 三、内核的功能
(1)中断处理程序
(2)进程同步与互斥
(3)进程调度
(4)进程控制与通信
(5)存储管理
(6)时钟管理
内核的各种功能通过执行原语操作来实现
```

## 四、进程并发与互斥

#### 进程间相互作用

```shell
# 一、相关进程和无关进程
1.相关进程:在逻辑上具有某种联系的进程
2.无关进程:在逻辑上没有联系的进程
3.举例
(1)为两个不同的源程序进行编译的进程，
它们可以并发执行，但它们之间无关
(2)三个进程，分别是读数据进程、处理数据进程、打印结果进程，
它们相互依赖、相互合作，是相关进程。

```

```shell
# 二、与时间有关的错误
对于相关进程来说，
可能有若干并发进程同时使用共享资源，
即一个进程一次使用未结束，
另一进程也开始使用，
形成交替使用共享资源。
结果:形成与时间有关的错误
```

#### 进程同步与互斥

```shell
#  一、进程的同步
进程的同步:
是指进程之间一种直接的协同工作关系，
一些进程相互合作共同完成一项任务。
例如：
进程A从硬盘上读记录，每读出一个记录就存入缓冲区，
进程B从缓冲区中取出记录加工，直至所有记录处理结束。
直接制约关系:
A若没有把记录读入缓冲区，B等待反之，
B若没有从缓冲区取出记录，A等待。
```

```shell
# 二、进程的互斥
在系统中，许多进程常常需要共享资源，
而这些共享资源往往需要排他性的使用，
即一次只能为一个进程服务，
因此，各进程间只能互斥使用这些资源，
进程间的这种关系就是进程的互斥。
例如：
多个进程竞争使用打印机、一些变量、表格等资源。
进程间的互斥是一种间接制约关系
```

```shell
# 三、临界区
# 1.临界资源:
若在系统中的某些资源一次只允许一个进程使用，
则这类资源称为临界资源或共享变量。
# 2.临界区:
访问临界资源的那段代码。
# 3.相关临界区
如果有若干进程共享某一临界资源(书上临界区错误，改正)，
则该临界区称为相关临界区 
# 4.相关临界区的调度使用原则
(1)当临界资源(书上是临界区，请改正)空闲时，
若有一个进程要求进入临界区，
应允许它立即进入。
---有空让进，有效利用资源。
(2)若有一个进程已在临界区，
其他要求进入临界区的进程必须等待。
--无空等待，互斥进入
(3)当没有进程在临界区，
而同时有多个进程西求进入临界区，
选择其一进入，其他等待。
--多种择
(4)任一进程进入临界区的要求应在有限时间满足
---有限等待，避免死等。
(5)处于等待状态的进程应放弃占用处理器。
-让权等待，避免忙等。
```

#### 信号量及P、V操作

```shell
为保证进程的同步与互斥，
系统中应该有解决这些问题的机制，
称为同步机制。
实际上，
同步是并发进程之间的
执行时序上的一种相互制约关系。
进程互斥的实质也是同步，
可把进程互斥看做是一种特殊的进程同步。
同步机制有两类:
硬件同步机制、软件同步机制。
# 一、信号量
# 1.信号量的提出
1965年，荷兰学者Dijkstra首先提出关于信号量的概念，
他把信号量定义为一个用于表示资源数目的整型量S，
与一般整型量不同，除初始化外，
仅能通过两个标准的操作P操作和V操作来访问。
# 2.P、V操作的使用
放在程序中，用P(S)和V(S)表达，
实现进程间的同步与互斥。
```

```shell
# 二、P、V操作
# 1.P操作定义
P(S)
S=S-1;
若S<0,将该进程状态置为等待状态，
然后将该进程的PCB
插入相应的S信号量等待队列队尾，
直到有其他进程在S上执行V操作为止;
# 2.V操作定义:
V(S)
S=S+1;
若S≤0，唤醒在S信号量队列中等待的一个进程，
将其状态改变为就绪态，
并将其插入就绪队列;
执行本操作的进程继续执行;
```

```shell
# 三、信号量与P、V操作的物理含义
信号量S表示某类可用的资源。
对于不同的资源，
用不同的信号表示。
S>0时，S表示某类资源的可用数量S<0时，
其绝对值表示排在S等待队列中进程的数目。
执行一次P操作，表示请求一个资源;
执行一次V操作，表示进程释放一个资源。
```

```shell
# 四、用P、V操作实现进程之间的互斥
假设有进程A、B竞争进入临界区，
用P、V操作实现进程之间的互斥。
首先定义互斥型信号量S，
并使之初值为1。
进程A:P(S);
临界区操作;V(S);
进程B:P(S);
临界区操作;V(S);
```

```shell
# 五、用P、V操作实现进程间的同步
解决思路:
如果有两个进程同步，
设置两个信号量S1，S2，
初始值可以设为0。
为了表达同步，
同一信号量的P、V操作分属于两个进程，

如例一:
进程A:
while(true)
把信息送入缓冲区;V(S1);P(S2);
进程B:
while(true)
P(S1);把信息从缓冲区取走;V(s2);
例二:
有三个进程，
进程get从输入设备上不断读取数据，
并放入缓冲区buffer1;
进程copy不断地将缓冲区buffer1中的内容
复制到缓冲区buffer2;
进程put侧不断将buffer2中的内容在打印机上输出。

三者的制约关系:
get进程必须先从设备读数据到bufferl;
copy进程才能从buffer1复制内容到buffer2;
最后put进程才能打印buffer2的内容。
输入设备
get
bufferl
copy
buffer2
put

反之，copy进程从bufferl取走数据之后，
get进程才能继续从设备读数据到buffer1;
put进程从buffer2取走数据之后，
copy进程才能复制buffer1的数据到buffer2.
copy
buffer2
put
get
bufferl
输入设备
故可以设置四个信号量来保证三者的执行顺序

信号量设置:
S1:初值为1，保证get进程能够从设备读数据到buffer1.
S2:初始值为0，copy进程能否将buffer1的内容复制到buffer2;
S3:初始值为0，put进程能否将buffer2的内容打印输出。
S4:初始值为1，保证buffer2缓冲区可以使用

输入设备
get
bufferl
copy
buffer2
put
进程get:
while(true)
P(S1);从输入设备读数据，并放入bufferl;V(s2);
```

```shell
# 六、信号量及P、V操作总结
1.P、V操作必须成对出现
2.互斥操作时，P、V操作出现在同一个进程
3.同步操作时，P、V操作出现在不同进程
4.既有同步，又有互斥操作时，
同步信号量P操作在前，
互斥信号量P操作在后，V操作顺序不限。
```

#### 经典的进程同步问题

```shell
# 一、简单生产者--消费者问题
问题描述:
设有一个生产者进程P，
一个消费者进程Q，
他们通过一个缓冲区联系起来，
如图4-2所示。
生产者(放产品)>缓冲区 只能存放一个产品
(取产品)>消费者

# 1.二者关系描述:
(1)生产者生产产品放入缓冲区，
消费者从缓冲区取产品，进行消费;
(2)P进程不能往已经“满”的缓冲区放产品，
Q进程不放从“空”缓冲中取产品。

# 2.信号量设置:
empty，初值为1，用于指示空缓冲区数量
full，初值为0，用于指示满缓冲区数量

# 3.解决方案:
进程P:
while(true)P(empty);生产一个产品;送产品到缓冲区;V(full);
进程Q:
while(true)P(full);
从缓冲区取产品
V(empty);消费产品
```

```shell
# 二、多个生产者--消费者问题
# 1.问题描述:
设有若干个生产者P1、P2、...
若干个消费者Q1，Q2,...
他们通过一个环形缓冲池联系起来，
如图4-3所示。
# 2.同步问题和信号量设置:
生产者不能往“满”缓冲区中放产品，
设置信号量empty，
初始值为k，指示缓冲池中空缓冲区数目。
消费者不能从“空”缓冲区中取产品，
设置信号量full，
初始值为0，指示缓冲池中的满缓冲区数目。
# 3.互斥问题和信号量设置:
缓冲池必须互斥访问，设置信号量mutex，初值为1.
# 4.其他变量设置
整型量i,j，初值为0,
分别用于指示空缓冲区和满缓冲区位置
# 例题
桌上有一个水果的盘子，
一次只能放一个水果，
父亲向盘中放苹果或橘子,
女儿专吃苹果，
儿子专吃橘子，
试用pv操作写出他们能正确同步的过程。
```

```shell
# 三、读者--写者问题
# 1.问题描述:
假定有某个共享文件F，
系统允许若干进程对文件F进行读或写。
读文件的进程称为读者，
写文件的进程称为写者，
他们遵守如下规定:
(1)多个进程可以同时读文件F
(2)当一个进程在对文件F进行写时，
不允许其他进程对文件进行读或写。
(3)当有进程正在读文件时不允许任何进程去写文件。
# 2.问题分析:
(1)写者进程与写者进程之间互斥互斥文件F
(2)写者进程与第一个读者之间互斥访问文件。
# 3.变量设定:
read_count:整型量，当前正在读的读者进程个数，
来一个读者，数量加1，走一个读者，数量减1;
mutex:互斥信号量，对read_count互斥访问。
write:互斥信号量，写者与写者的互斥，
写者与读者之间的互斥。
# 4.算法:
读者进程:while(true)
P(mutex);
read_count=readcount+l;if(read_count==1)P(write);V(mutex);读文件;
写者进程:while(true){
P(write)写文件;V(write);
P(mutex);
read_count=readcount-1;if(read_count==0);V(write);
V(mutex);

例题
若有一个文件F，供多进程读。
现把进程分成A、B两组，
规定同组的进程可以同时读文件F，
但不同组的进程不能同时读文件F，
试用PV操作写出该问题的同步算法。
```

```shell
# 四、同步与互斥的综合应用
例4-1:路口单双号交通管制
问题描述:
某个城市为了解决市内汽车太多、拥堵问题，
出台一项措施:
对进入市区的机动车辆实行单双号限行办法，
规定单号单行，双号双行。
有一个进入市区中心的路口，
进入该路口的道路有一条，
离开该路口道路有两条，
一条进入市区，一条进入环线。
路口设有车牌识别设备和放行栅栏。
如图4-4所示:
```

#### 管程

```shell
#  一、管程的提出
信号量及PV操作的缺点:
(1)程序易读性差
(2)程序不利于修改和维护
(3)正确性难以保证
为了更易于编写正确的程序，引入管程
```

```shell
# 二、管程的概念及组成
# 定义:
是一个由过程、变量及数据结构等组成的一个集合，
它们组成一个特殊的模块或软件包。
进程可在任何需要的时候调用管程中的过程。
# 组成:
管程名称、共享数据说明、对数据进行操作的组过程、
对共享数据赋初值的语句。
```

#### 进程通信

```shell
#  一、共享内存
# 1.原理
在相互通信的进程之间设有一个公共内存区，
一组进程向该公共内存中写，
另一组进程从公共内存中读，
通过这种方式实现两组进程之间的信息交换
```

```shell
# 二、消息机制--消息缓冲
# 1.消息缓冲通信原理:
进程间的数据交换，
是以格式化的消息(也称为报文)为单位的。
程序员直接利用操作系统提供的一组通信命令(原语)，
实现大量数据的传递，
通信过程对用户是透明的。

消息格式:struct message_bufferl
int sender;//发送者进程标识符//消息长度int size;
char *text;//消息正文
struct message_buffer *next;//指向下一个消息缓冲区的指针
# 2.信箱通信原理:
为了实现进程间的通信，
可以设计一个通信机构--信箱，
以发送信件和接收信件为进程间通信的基本方式。
```

```shell
# 三、管道通信
所谓“管道”，
是指用于连接一个读进程和一个写进程
以实现他们之间通信的一个共享文件，又名pipe文件。
最早出现在UNIX系统中，
是UNIX系统进程通信的一大特色
Process A写
共享文件
Process B读
pipe 通信机制
```

## 五、死锁

```shell
在多道程序系统中，同时有多个进程并发执行，
共享系统资源，从而提高了系统资源利用率，
提高了系统的处理能力。
但是，在进行资源分配时会产生一个随机性的错误---死锁。
在许多应用中，如实时控制和监视系统中，
如果遇到死锁会带来很大的危害。s
```

#### 死锁的产生

```shell
# 一、死锁的定义
指在多道程序系统中，
一组进程中的每一个进程均无限期地等待
被该组进程中的另一个进程所占用
且永远不会释放的资源。
处于死锁状态的进程称为死锁进程。
```

```shell
# 二、产生死锁的原因
# 1.资源的概念
(1)永久性资源(可重用资源):
如内存、外部设备、处理器等硬件资源。
各种数据文件、表格、共享程序代码等软件资源
(2)临时性资源(消耗性资源):
指由某个进程产生、只为另一个进程
使用一次或经过短暂时间后便不再使用的资源。
如I/O和时钟中断信号、同步信号、消息等。
# 2.产生死锁的原因
(1)竞争资源系统在资源分配时出现失误、
进程间对资源的相互争夺而造成僵局。
(2)进程推进顺序不合理
例5.1申请不同类资源产生死锁
进程P1和P2在运行中都使用输入、输出设备，
假定系统中只有一台输入设备和一台输出设备，
则进程P1和P2可有如下形式:
例5.1申请不同类资源产生死锁
P1:
申请一台输入设备申请一台输出设备
使用各设备;释放输入设备释放输出设备;
P2:
I申请一台输出设备II申请一台输入设备
使用各设备;释放输出设备释放输入设备;s

例5.1申请不同类资源产生死锁
若进程交替执行，如下:
P1:申请一台输入设备
P2:申请一台输出设备
P1:申请一台输出设备
P2:申请一台输入设备
已分配
P1
申请

例5.2申请同类资源产生死锁
假设有一类可重用资源R，如内存，
它包含m个页面，由n个进程P」、P2，...，P2(2≤m≤n)共享。
假定每个进程按下述顺序依次申请和释放页面
申请一个页面
申请一个页面
释放一个页面
释放一个页面
n=3,m=2的情况

例5.3 P、V操作使用不当产生的死锁
对于第四章 生产者--消费者问题，
如果把p(mutex)放在P(empty)和P(FULL)之前，
就会产生死锁。
考虑当
生产者进程:
消费者进程:
empty=0，full=n的情况第一种情况:
假设生产者进程占有处理器，此时，
执行完P(mutex)，再执行P(emtpy)时，
生产者进程阻塞，让出处理器，
消费者进程执行P(mutex)也会阻塞，
此时产生死锁。
p(mutex);P(empty);
p(mutex);P(full);

例5.4对临时性资源的使用不加限制产生的死锁
在进程通信时使用的信件可以看做是一种临时性资源，
如果对信件的发送和接收不加限制，则可能引起死锁。
比如，进程P1等待进程P3的信件S3，
S3到来后再向进程P2发送信件S1，
P2又要等待P1的信件S1到来后再向P3发送信件S2，
P3进程也要等待进程P2的信件S2到来后才能发送信件S3。
例5.4对临时性资源的使用不加限制产生的死锁P1:..
receive (p3, s3);send (p2,s1);
P2:...
receive (pl, s1);send (p3, s2) ;P3:..
receive (p2, s2);send (pl,s3);

```

```shell
# 三、产生死锁的四个必要条件
对于永久性资源，
产生死锁的四个必要条件:
- 互斥条件
- 不可剥夺条件
- 请求和保持条件
- 循环等待条件
```

```shell
# 四、解决死锁的方法
- 预防死锁
- 避免死锁
- 检测与解除死锁
- 忽略死锁
```

